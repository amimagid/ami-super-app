/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/named-placeholders";
exports.ids = ["vendor-chunks/named-placeholders"];
exports.modules = {

/***/ "(rsc)/./node_modules/named-placeholders/index.js":
/*!**************************************************!*\
  !*** ./node_modules/named-placeholders/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// based on code from Brian White @mscdex mariasql library - https://github.com/mscdex/node-mariasql/blob/master/lib/Client.js#L272-L332\n// License: https://github.com/mscdex/node-mariasql/blob/master/LICENSE\nconst RE_PARAM = /(?:\\?)|(?::(\\d+|(?:[a-zA-Z][a-zA-Z0-9_]*)))/g, DQUOTE = 34, SQUOTE = 39, BSLASH = 92;\nfunction parse(query) {\n    let ppos = RE_PARAM.exec(query);\n    let curpos = 0;\n    let start = 0;\n    let end;\n    const parts = [];\n    let inQuote = false;\n    let escape = false;\n    let qchr;\n    const tokens = [];\n    let qcnt = 0;\n    let lastTokenEndPos = 0;\n    let i;\n    if (ppos) {\n        do {\n            for(i = curpos, end = ppos.index; i < end; ++i){\n                let chr = query.charCodeAt(i);\n                if (chr === BSLASH) escape = !escape;\n                else {\n                    if (escape) {\n                        escape = false;\n                        continue;\n                    }\n                    if (inQuote && chr === qchr) {\n                        if (query.charCodeAt(i + 1) === qchr) {\n                            // quote escaped via \"\" or ''\n                            ++i;\n                            continue;\n                        }\n                        inQuote = false;\n                    } else if (chr === DQUOTE || chr === SQUOTE) {\n                        inQuote = true;\n                        qchr = chr;\n                    }\n                }\n            }\n            if (!inQuote) {\n                parts.push(query.substring(start, end));\n                tokens.push(ppos[0].length === 1 ? qcnt++ : ppos[1]);\n                start = end + ppos[0].length;\n                lastTokenEndPos = start;\n            }\n            curpos = end + ppos[0].length;\n        }while (ppos = RE_PARAM.exec(query));\n        if (tokens.length) {\n            if (curpos < query.length) {\n                parts.push(query.substring(lastTokenEndPos));\n            }\n            return [\n                parts,\n                tokens\n            ];\n        }\n    }\n    return [\n        query\n    ];\n}\n;\nfunction createCompiler(config) {\n    if (!config) config = {};\n    if (!config.placeholder) {\n        config.placeholder = \"?\";\n    }\n    let ncache = 100;\n    let cache;\n    if (typeof config.cache === \"number\") {\n        ncache = config.cache;\n    }\n    if (typeof config.cache === \"object\") {\n        cache = config.cache;\n    }\n    if (config.cache !== false && !cache) {\n        cache = new (__webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/named-placeholders/node_modules/lru-cache/index.js\"))({\n            max: ncache\n        });\n    }\n    function toArrayParams(tree, params) {\n        const arr = [];\n        if (tree.length == 1) {\n            return [\n                tree[0],\n                []\n            ];\n        }\n        if (typeof params == \"undefined\") throw new Error(\"Named query contains placeholders, but parameters object is undefined\");\n        const tokens = tree[1];\n        for(let i = 0; i < tokens.length; ++i){\n            arr.push(params[tokens[i]]);\n        }\n        return [\n            tree[0],\n            arr\n        ];\n    }\n    function noTailingSemicolon(s) {\n        if (s.slice(-1) == \":\") {\n            return s.slice(0, -1);\n        }\n        return s;\n    }\n    function join(tree) {\n        if (tree.length == 1) {\n            return tree;\n        }\n        let unnamed = noTailingSemicolon(tree[0][0]);\n        for(let i = 1; i < tree[0].length; ++i){\n            if (tree[0][i - 1].slice(-1) == \":\") {\n                unnamed += config.placeholder;\n            }\n            unnamed += config.placeholder;\n            unnamed += noTailingSemicolon(tree[0][i]);\n        }\n        const last = tree[0][tree[0].length - 1];\n        if (tree[0].length == tree[1].length) {\n            if (last.slice(-1) == \":\") {\n                unnamed += config.placeholder;\n            }\n            unnamed += config.placeholder;\n        }\n        return [\n            unnamed,\n            tree[1]\n        ];\n    }\n    function compile(query, paramsObj) {\n        let tree;\n        if (cache && (tree = cache.get(query))) {\n            return toArrayParams(tree, paramsObj);\n        }\n        tree = join(parse(query));\n        if (cache) {\n            cache.set(query, tree);\n        }\n        return toArrayParams(tree, paramsObj);\n    }\n    compile.parse = parse;\n    return compile;\n}\n// named :one :two to postgres-style numbered $1 $2 $3\nfunction toNumbered(q, params) {\n    const tree = parse(q);\n    const paramsArr = [];\n    if (tree.length == 1) {\n        return [\n            tree[0],\n            paramsArr\n        ];\n    }\n    const pIndexes = {};\n    let pLastIndex = 0;\n    let qs = \"\";\n    let varIndex;\n    const varNames = [];\n    for(let i = 0; i < tree[0].length; ++i){\n        varIndex = pIndexes[tree[1][i]];\n        if (!varIndex) {\n            varIndex = ++pLastIndex;\n            pIndexes[tree[1][i]] = varIndex;\n        }\n        if (tree[1][i]) {\n            varNames[varIndex - 1] = tree[1][i];\n            qs += tree[0][i] + \"$\" + varIndex;\n        } else {\n            qs += tree[0][i];\n        }\n    }\n    return [\n        qs,\n        varNames.map((n)=>params[n])\n    ];\n}\nmodule.exports = createCompiler;\nmodule.exports.toNumbered = toNumbered;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmFtZWQtcGxhY2Vob2xkZXJzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsd0lBQXdJO0FBQ3hJLHVFQUF1RTtBQUV2RSxNQUFNQSxXQUFXLGdEQUNqQkMsU0FBUyxJQUNUQyxTQUFTLElBQ1RDLFNBQVM7QUFFVCxTQUFTQyxNQUFNQyxLQUFLO0lBQ2xCLElBQUlDLE9BQU9OLFNBQVNPLElBQUksQ0FBQ0Y7SUFDekIsSUFBSUcsU0FBUztJQUNiLElBQUlDLFFBQVE7SUFDWixJQUFJQztJQUNKLE1BQU1DLFFBQVEsRUFBRTtJQUNoQixJQUFJQyxVQUFVO0lBQ2QsSUFBSUMsU0FBUztJQUNiLElBQUlDO0lBQ0osTUFBTUMsU0FBUyxFQUFFO0lBQ2pCLElBQUlDLE9BQU87SUFDWCxJQUFJQyxrQkFBa0I7SUFDdEIsSUFBSUM7SUFFSixJQUFJWixNQUFNO1FBQ1IsR0FBRztZQUNELElBQUtZLElBQUVWLFFBQU9FLE1BQUlKLEtBQUthLEtBQUssRUFBRUQsSUFBRVIsS0FBSyxFQUFFUSxFQUFHO2dCQUN4QyxJQUFJRSxNQUFNZixNQUFNZ0IsVUFBVSxDQUFDSDtnQkFDM0IsSUFBSUUsUUFBUWpCLFFBQ1pVLFNBQVMsQ0FBQ0E7cUJBQ0w7b0JBQ0gsSUFBSUEsUUFBUTt3QkFDVkEsU0FBUzt3QkFDVDtvQkFDRjtvQkFDQSxJQUFJRCxXQUFXUSxRQUFRTixNQUFNO3dCQUMzQixJQUFJVCxNQUFNZ0IsVUFBVSxDQUFDSCxJQUFJLE9BQU9KLE1BQU07NEJBQ3BDLDZCQUE2Qjs0QkFDN0IsRUFBRUk7NEJBQ0Y7d0JBQ0Y7d0JBQ0FOLFVBQVU7b0JBQ1osT0FBTyxJQUFJUSxRQUFRbkIsVUFBVW1CLFFBQVFsQixRQUFRO3dCQUMzQ1UsVUFBVTt3QkFDVkUsT0FBT007b0JBQ1Q7Z0JBQ0Y7WUFDRjtZQUNBLElBQUksQ0FBQ1IsU0FBUztnQkFDWkQsTUFBTVcsSUFBSSxDQUFDakIsTUFBTWtCLFNBQVMsQ0FBQ2QsT0FBT0M7Z0JB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QUMvQixJQUFJLENBQUNtQyxVQUFVO1lBQ2JBLFdBQVcsRUFBRUY7WUFDYkQsUUFBUSxDQUFDakIsSUFBSSxDQUFDLEVBQUUsQ0FBQ2YsRUFBRSxDQUFDLEdBQUdtQztRQUN6QjtRQUNBLElBQUlwQixJQUFJLENBQUMsRUFBRSxDQUFDZixFQUFFLEVBQUU7WUFDZG9DLFFBQVEsQ0FBQ0QsV0FBVyxFQUFFLEdBQUdwQixJQUFJLENBQUMsRUFBRSxDQUFDZixFQUFFO1lBQ25Da0MsTUFBTW5CLElBQUksQ0FBQyxFQUFFLENBQUNmLEVBQUUsR0FBRyxNQUFNbUM7UUFDM0IsT0FBTztZQUNMRCxNQUFNbkIsSUFBSSxDQUFDLEVBQUUsQ0FBQ2YsRUFBRTtRQUNsQjtJQUNGO0lBQ0EsT0FBTztRQUFDa0M7UUFBSUUsU0FBU0MsR0FBRyxDQUFDQyxDQUFBQSxJQUFLdEIsTUFBTSxDQUFDc0IsRUFBRTtLQUFFO0FBQzNDO0FBRUFDLE9BQU9DLE9BQU8sR0FBR2pDO0FBQ2pCZ0MseUJBQXlCLEdBQUdWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW1pLXN1cGVyLWFwcC8uL25vZGVfbW9kdWxlcy9uYW1lZC1wbGFjZWhvbGRlcnMvaW5kZXguanM/MmJlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIGJhc2VkIG9uIGNvZGUgZnJvbSBCcmlhbiBXaGl0ZSBAbXNjZGV4IG1hcmlhc3FsIGxpYnJhcnkgLSBodHRwczovL2dpdGh1Yi5jb20vbXNjZGV4L25vZGUtbWFyaWFzcWwvYmxvYi9tYXN0ZXIvbGliL0NsaWVudC5qcyNMMjcyLUwzMzJcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tc2NkZXgvbm9kZS1tYXJpYXNxbC9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbmNvbnN0IFJFX1BBUkFNID0gLyg/OlxcPyl8KD86OihcXGQrfCg/OlthLXpBLVpdW2EtekEtWjAtOV9dKikpKS9nLFxuRFFVT1RFID0gMzQsXG5TUVVPVEUgPSAzOSxcbkJTTEFTSCA9IDkyO1xuXG5mdW5jdGlvbiBwYXJzZShxdWVyeSkge1xuICBsZXQgcHBvcyA9IFJFX1BBUkFNLmV4ZWMocXVlcnkpO1xuICBsZXQgY3VycG9zID0gMDtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZDtcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgbGV0IGluUXVvdGUgPSBmYWxzZTtcbiAgbGV0IGVzY2FwZSA9IGZhbHNlO1xuICBsZXQgcWNocjtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGxldCBxY250ID0gMDtcbiAgbGV0IGxhc3RUb2tlbkVuZFBvcyA9IDA7XG4gIGxldCBpO1xuXG4gIGlmIChwcG9zKSB7XG4gICAgZG8ge1xuICAgICAgZm9yIChpPWN1cnBvcyxlbmQ9cHBvcy5pbmRleDsgaTxlbmQ7ICsraSkge1xuICAgICAgICBsZXQgY2hyID0gcXVlcnkuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNociA9PT0gQlNMQVNIKVxuICAgICAgICBlc2NhcGUgPSAhZXNjYXBlO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5RdW90ZSAmJiBjaHIgPT09IHFjaHIpIHtcbiAgICAgICAgICAgIGlmIChxdWVyeS5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gcWNocikge1xuICAgICAgICAgICAgICAvLyBxdW90ZSBlc2NhcGVkIHZpYSBcIlwiIG9yICcnXG4gICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpblF1b3RlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaHIgPT09IERRVU9URSB8fCBjaHIgPT09IFNRVU9URSkge1xuICAgICAgICAgICAgaW5RdW90ZSA9IHRydWU7XG4gICAgICAgICAgICBxY2hyID0gY2hyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpblF1b3RlKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocXVlcnkuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgdG9rZW5zLnB1c2gocHBvc1swXS5sZW5ndGggPT09IDEgPyBxY250KysgOiBwcG9zWzFdKTtcbiAgICAgICAgc3RhcnQgPSBlbmQgKyBwcG9zWzBdLmxlbmd0aDtcbiAgICAgICAgbGFzdFRva2VuRW5kUG9zID0gc3RhcnQ7XG4gICAgICB9XG4gICAgICBjdXJwb3MgPSBlbmQgKyBwcG9zWzBdLmxlbmd0aDtcbiAgICB9IHdoaWxlIChwcG9zID0gUkVfUEFSQU0uZXhlYyhxdWVyeSkpO1xuXG4gICAgaWYgKHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIGlmIChjdXJwb3MgPCBxdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgcGFydHMucHVzaChxdWVyeS5zdWJzdHJpbmcobGFzdFRva2VuRW5kUG9zKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3BhcnRzLCB0b2tlbnNdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3F1ZXJ5XTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyKGNvbmZpZykge1xuICBpZiAoIWNvbmZpZylcbiAgY29uZmlnID0ge307XG4gIGlmICghY29uZmlnLnBsYWNlaG9sZGVyKSB7XG4gICAgY29uZmlnLnBsYWNlaG9sZGVyID0gJz8nO1xuICB9XG4gIGxldCBuY2FjaGUgPSAxMDA7XG4gIGxldCBjYWNoZTtcbiAgaWYgKHR5cGVvZiBjb25maWcuY2FjaGUgPT09ICdudW1iZXInKSB7XG4gICAgbmNhY2hlID0gY29uZmlnLmNhY2hlO1xuICB9XG4gIGlmICh0eXBlb2YgY29uZmlnLmNhY2hlID09PSAnb2JqZWN0Jykge1xuICAgIGNhY2hlID0gY29uZmlnLmNhY2hlO1xuICB9XG4gIGlmIChjb25maWcuY2FjaGUgIT09IGZhbHNlICYmICFjYWNoZSkge1xuICAgIGNhY2hlID0gbmV3IChyZXF1aXJlKCdscnUtY2FjaGUnKSkoeyBtYXg6IG5jYWNoZSB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvQXJyYXlQYXJhbXModHJlZSwgcGFyYW1zKSB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgaWYgKHRyZWUubGVuZ3RoID09IDEpIHtcbiAgICAgIHJldHVybiBbdHJlZVswXSwgW11dO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICd1bmRlZmluZWQnKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYW1lZCBxdWVyeSBjb250YWlucyBwbGFjZWhvbGRlcnMsIGJ1dCBwYXJhbWV0ZXJzIG9iamVjdCBpcyB1bmRlZmluZWQnKTtcblxuICAgIGNvbnN0IHRva2VucyA9IHRyZWVbMV07XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgdG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBhcnIucHVzaChwYXJhbXNbdG9rZW5zW2ldXSk7XG4gICAgfVxuICAgIHJldHVybiBbdHJlZVswXSwgYXJyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vVGFpbGluZ1NlbWljb2xvbihzKSB7XG4gICAgaWYgKHMuc2xpY2UoLTEpID09ICc6Jykge1xuICAgICAgcmV0dXJuIHMuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGpvaW4odHJlZSkge1xuICAgIGlmICh0cmVlLmxlbmd0aCA9PSAxKSB7XG4gICAgICByZXR1cm4gdHJlZTtcbiAgICB9XG5cbiAgICBsZXQgdW5uYW1lZCA9IG5vVGFpbGluZ1NlbWljb2xvbih0cmVlWzBdWzBdKTtcbiAgICBmb3IgKGxldCBpPTE7IGkgPCB0cmVlWzBdLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodHJlZVswXVtpLTFdLnNsaWNlKC0xKSA9PSAnOicpIHtcbiAgICAgICAgdW5uYW1lZCArPSBjb25maWcucGxhY2Vob2xkZXI7XG4gICAgICB9XG4gICAgICB1bm5hbWVkICs9IGNvbmZpZy5wbGFjZWhvbGRlcjtcbiAgICAgIHVubmFtZWQgKz0gbm9UYWlsaW5nU2VtaWNvbG9uKHRyZWVbMF1baV0pO1xuICAgIH1cblxuICAgIGNvbnN0IGxhc3QgPSB0cmVlWzBdW3RyZWVbMF0ubGVuZ3RoIC0xXTtcbiAgICBpZiAodHJlZVswXS5sZW5ndGggPT0gdHJlZVsxXS5sZW5ndGgpIHtcbiAgICAgIGlmIChsYXN0LnNsaWNlKC0xKSA9PSAnOicpIHtcbiAgICAgICAgdW5uYW1lZCArPSBjb25maWcucGxhY2Vob2xkZXI7XG4gICAgICB9XG4gICAgICB1bm5hbWVkICs9IGNvbmZpZy5wbGFjZWhvbGRlcjtcbiAgICB9XG4gICAgcmV0dXJuIFt1bm5hbWVkLCB0cmVlWzFdXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBpbGUocXVlcnksIHBhcmFtc09iaikge1xuICAgIGxldCB0cmVlO1xuICAgIGlmIChjYWNoZSAmJiAodHJlZSA9IGNhY2hlLmdldChxdWVyeSkpKSB7XG4gICAgICByZXR1cm4gdG9BcnJheVBhcmFtcyh0cmVlLCBwYXJhbXNPYmopXG4gICAgfVxuICAgIHRyZWUgPSBqb2luKHBhcnNlKHF1ZXJ5KSk7XG4gICAgaWYoY2FjaGUpIHtcbiAgICAgIGNhY2hlLnNldChxdWVyeSwgdHJlZSk7XG4gICAgfVxuICAgIHJldHVybiB0b0FycmF5UGFyYW1zKHRyZWUsIHBhcmFtc09iaik7XG4gIH1cblxuICBjb21waWxlLnBhcnNlID0gcGFyc2U7XG4gIHJldHVybiBjb21waWxlO1xufVxuXG4vLyBuYW1lZCA6b25lIDp0d28gdG8gcG9zdGdyZXMtc3R5bGUgbnVtYmVyZWQgJDEgJDIgJDNcbmZ1bmN0aW9uIHRvTnVtYmVyZWQocSwgcGFyYW1zKSB7XG4gIGNvbnN0IHRyZWUgPSBwYXJzZShxKTtcbiAgY29uc3QgcGFyYW1zQXJyID0gW107XG4gIGlmICh0cmVlLmxlbmd0aCA9PSAxKSB7XG4gICAgcmV0dXJuIFt0cmVlWzBdLCBwYXJhbXNBcnJdO1xuICB9XG5cbiAgY29uc3QgcEluZGV4ZXMgPSB7fTtcbiAgbGV0IHBMYXN0SW5kZXggPSAwO1xuICBsZXQgcXMgPSAnJztcbiAgbGV0IHZhckluZGV4O1xuICBjb25zdCB2YXJOYW1lcyA9IFtdO1xuICBmb3IgKGxldCBpPTA7IGkgPCB0cmVlWzBdLmxlbmd0aDsgKytpKSB7XG4gICAgdmFySW5kZXggPSBwSW5kZXhlc1t0cmVlWzFdW2ldXTtcbiAgICBpZiAoIXZhckluZGV4KSB7XG4gICAgICB2YXJJbmRleCA9ICsrcExhc3RJbmRleDtcbiAgICAgIHBJbmRleGVzW3RyZWVbMV1baV1dID0gdmFySW5kZXg7XG4gICAgfVxuICAgIGlmICh0cmVlWzFdW2ldKSB7XG4gICAgICB2YXJOYW1lc1t2YXJJbmRleCAtIDFdID0gdHJlZVsxXVtpXTtcbiAgICAgIHFzICs9IHRyZWVbMF1baV0gKyAnJCcgKyB2YXJJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXMgKz0gdHJlZVswXVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtxcywgdmFyTmFtZXMubWFwKG4gPT4gcGFyYW1zW25dKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQ29tcGlsZXI7XG5tb2R1bGUuZXhwb3J0cy50b051bWJlcmVkID0gdG9OdW1iZXJlZDtcbiJdLCJuYW1lcyI6WyJSRV9QQVJBTSIsIkRRVU9URSIsIlNRVU9URSIsIkJTTEFTSCIsInBhcnNlIiwicXVlcnkiLCJwcG9zIiwiZXhlYyIsImN1cnBvcyIsInN0YXJ0IiwiZW5kIiwicGFydHMiLCJpblF1b3RlIiwiZXNjYXBlIiwicWNociIsInRva2VucyIsInFjbnQiLCJsYXN0VG9rZW5FbmRQb3MiLCJpIiwiaW5kZXgiLCJjaHIiLCJjaGFyQ29kZUF0IiwicHVzaCIsInN1YnN0cmluZyIsImxlbmd0aCIsImNyZWF0ZUNvbXBpbGVyIiwiY29uZmlnIiwicGxhY2Vob2xkZXIiLCJuY2FjaGUiLCJjYWNoZSIsInJlcXVpcmUiLCJtYXgiLCJ0b0FycmF5UGFyYW1zIiwidHJlZSIsInBhcmFtcyIsImFyciIsIkVycm9yIiwibm9UYWlsaW5nU2VtaWNvbG9uIiwicyIsInNsaWNlIiwiam9pbiIsInVubmFtZWQiLCJsYXN0IiwiY29tcGlsZSIsInBhcmFtc09iaiIsImdldCIsInNldCIsInRvTnVtYmVyZWQiLCJxIiwicGFyYW1zQXJyIiwicEluZGV4ZXMiLCJwTGFzdEluZGV4IiwicXMiLCJ2YXJJbmRleCIsInZhck5hbWVzIiwibWFwIiwibiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/named-placeholders/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/named-placeholders/node_modules/lru-cache/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/named-placeholders/node_modules/lru-cache/index.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("const perf = typeof performance === \"object\" && performance && typeof performance.now === \"function\" ? performance : Date;\nconst hasAbortController = typeof AbortController === \"function\";\n// minimal backwards-compatibility polyfill\n// this doesn't have nearly all the checks and whatnot that\n// actual AbortController/Signal has, but it's enough for\n// our purposes, and if used properly, behaves the same.\nconst AC = hasAbortController ? AbortController : class AbortController1 {\n    constructor(){\n        this.signal = new AS();\n    }\n    abort(reason = new Error(\"This operation was aborted\")) {\n        this.signal.reason = this.signal.reason || reason;\n        this.signal.aborted = true;\n        this.signal.dispatchEvent({\n            type: \"abort\",\n            target: this.signal\n        });\n    }\n};\nconst hasAbortSignal = typeof AbortSignal === \"function\";\n// Some polyfills put this on the AC class, not global\nconst hasACAbortSignal = typeof AC.AbortSignal === \"function\";\nconst AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal1 {\n    constructor(){\n        this.reason = undefined;\n        this.aborted = false;\n        this._listeners = [];\n    }\n    dispatchEvent(e) {\n        if (e.type === \"abort\") {\n            this.aborted = true;\n            this.onabort(e);\n            this._listeners.forEach((f)=>f(e), this);\n        }\n    }\n    onabort() {}\n    addEventListener(ev, fn) {\n        if (ev === \"abort\") {\n            this._listeners.push(fn);\n        }\n    }\n    removeEventListener(ev, fn) {\n        if (ev === \"abort\") {\n            this._listeners = this._listeners.filter((f)=>f !== fn);\n        }\n    }\n};\nconst warned = new Set();\nconst deprecatedOption = (opt, instead)=>{\n    const code = `LRU_CACHE_OPTION_${opt}`;\n    if (shouldWarn(code)) {\n        warn(code, `${opt} option`, `options.${instead}`, LRUCache);\n    }\n};\nconst deprecatedMethod = (method, instead)=>{\n    const code = `LRU_CACHE_METHOD_${method}`;\n    if (shouldWarn(code)) {\n        const { prototype } = LRUCache;\n        const { get } = Object.getOwnPropertyDescriptor(prototype, method);\n        warn(code, `${method} method`, `cache.${instead}()`, get);\n    }\n};\nconst deprecatedProperty = (field, instead)=>{\n    const code = `LRU_CACHE_PROPERTY_${field}`;\n    if (shouldWarn(code)) {\n        const { prototype } = LRUCache;\n        const { get } = Object.getOwnPropertyDescriptor(prototype, field);\n        warn(code, `${field} property`, `cache.${instead}`, get);\n    }\n};\nconst emitWarning = (...a)=>{\n    typeof process === \"object\" && process && typeof process.emitWarning === \"function\" ? process.emitWarning(...a) : console.error(...a);\n};\nconst shouldWarn = (code)=>!warned.has(code);\nconst warn = (code, what, instead, fn)=>{\n    warned.add(code);\n    const msg = `The ${what} is deprecated. Please use ${instead} instead.`;\n    emitWarning(msg, \"DeprecationWarning\", code, fn);\n};\nconst isPosInt = (n)=>n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* istanbul ignore next - This is a little bit ridiculous, tbh.\n * The maximum array length is 2^32-1 or thereabouts on most JS impls.\n * And well before that point, you're caching the entire world, I mean,\n * that's ~32GB of just integers for the next/prev links, plus whatever\n * else to hold that many keys and values.  Just filling the memory with\n * zeroes at init time is brutal when you get that big.\n * But why not be complete?\n * Maybe in the future, these limits will have expanded. */ const getUintArray = (max)=>!isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\nclass ZeroArray extends Array {\n    constructor(size){\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    constructor(max){\n        if (max === 0) {\n            return [];\n        }\n        const UintArray = getUintArray(max);\n        this.heap = new UintArray(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\nclass LRUCache {\n    constructor(options = {}){\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, fetchContext, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;\n        // deprecated options, don't trigger a warning for getting them if\n        // the thing being passed in is another LRUCache we're copying.\n        const { length, maxAge, stale } = options instanceof LRUCache ? {} : options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError(\"max option must be a nonnegative integer\");\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error(\"invalid max value: \" + max);\n        }\n        this.max = max;\n        this.maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.maxSize;\n        this.sizeCalculation = sizeCalculation || length;\n        if (this.sizeCalculation) {\n            if (!this.maxSize && !this.maxEntrySize) {\n                throw new TypeError(\"cannot set sizeCalculation without setting maxSize or maxEntrySize\");\n            }\n            if (typeof this.sizeCalculation !== \"function\") {\n                throw new TypeError(\"sizeCalculation set to non-function\");\n            }\n        }\n        this.fetchMethod = fetchMethod || null;\n        if (this.fetchMethod && typeof this.fetchMethod !== \"function\") {\n            throw new TypeError(\"fetchMethod must be a function if specified\");\n        }\n        this.fetchContext = fetchContext;\n        if (!this.fetchMethod && fetchContext !== undefined) {\n            throw new TypeError(\"cannot set fetchContext without fetchMethod\");\n        }\n        this.keyMap = new Map();\n        this.keyList = new Array(max).fill(null);\n        this.valList = new Array(max).fill(null);\n        this.next = new UintArray(max);\n        this.prev = new UintArray(max);\n        this.head = 0;\n        this.tail = 0;\n        this.free = new Stack(max);\n        this.initialFill = 1;\n        this.size = 0;\n        if (typeof dispose === \"function\") {\n            this.dispose = dispose;\n        }\n        if (typeof disposeAfter === \"function\") {\n            this.disposeAfter = disposeAfter;\n            this.disposed = [];\n        } else {\n            this.disposeAfter = null;\n            this.disposed = null;\n        }\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.maxSize !== 0) {\n                if (!isPosInt(this.maxSize)) {\n                    throw new TypeError(\"maxSize must be a positive integer if specified\");\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError(\"maxEntrySize must be a positive integer if specified\");\n            }\n            this.initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale || !!stale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || maxAge || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError(\"ttl must be a positive integer if specified\");\n            }\n            this.initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {\n            throw new TypeError(\"At least one of max, maxSize, or ttl is required\");\n        }\n        if (!this.ttlAutopurge && !this.max && !this.maxSize) {\n            const code = \"LRU_CACHE_UNBOUNDED\";\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = \"TTL caching without ttlAutopurge, max, or maxSize can \" + \"result in unbounded memory consumption.\";\n                emitWarning(msg, \"UnboundedCacheWarning\", code, LRUCache);\n            }\n        }\n        if (stale) {\n            deprecatedOption(\"stale\", \"allowStale\");\n        }\n        if (maxAge) {\n            deprecatedOption(\"maxAge\", \"ttl\");\n        }\n        if (length) {\n            deprecatedOption(\"length\", \"sizeCalculation\");\n        }\n    }\n    getRemainingTTL(key) {\n        return this.has(key, {\n            updateAgeOnHas: false\n        }) ? Infinity : 0;\n    }\n    initializeTTLTracking() {\n        this.ttls = new ZeroArray(this.max);\n        this.starts = new ZeroArray(this.max);\n        this.setItemTTL = (index, ttl, start = perf.now())=>{\n            this.starts[index] = ttl !== 0 ? start : 0;\n            this.ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(()=>{\n                    if (this.isStale(index)) {\n                        this.delete(this.keyList[index]);\n                    }\n                }, ttl + 1);\n                /* istanbul ignore else - unref() not supported on all platforms */ if (t.unref) {\n                    t.unref();\n                }\n            }\n        };\n        this.updateItemAge = (index)=>{\n            this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.statusTTL = (status, index)=>{\n            if (status) {\n                status.ttl = this.ttls[index];\n                status.start = this.starts[index];\n                status.now = cachedNow || getNow();\n                status.remainingTTL = status.now + status.ttl - status.start;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = ()=>{\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(()=>cachedNow = 0, this.ttlResolution);\n                /* istanbul ignore else - not available on all platforms */ if (t.unref) {\n                    t.unref();\n                }\n            }\n            return n;\n        };\n        this.getRemainingTTL = (key)=>{\n            const index = this.keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());\n        };\n        this.isStale = (index)=>{\n            return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];\n        };\n    }\n    updateItemAge(_index) {}\n    statusTTL(_status, _index) {}\n    setItemTTL(_index, _ttl, _start) {}\n    isStale(_index) {\n        return false;\n    }\n    initializeSizeTracking() {\n        this.calculatedSize = 0;\n        this.sizes = new ZeroArray(this.max);\n        this.removeItemSize = (index)=>{\n            this.calculatedSize -= this.sizes[index];\n            this.sizes[index] = 0;\n        };\n        this.requireSize = (k, v, size, sizeCalculation)=>{\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== \"function\") {\n                        throw new TypeError(\"sizeCalculation must be a function\");\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError(\"sizeCalculation return invalid (expect positive integer)\");\n                    }\n                } else {\n                    throw new TypeError(\"invalid size value (must be positive integer). \" + \"When maxSize or maxEntrySize is used, sizeCalculation or size \" + \"must be set.\");\n                }\n            }\n            return size;\n        };\n        this.addItemSize = (index, size, status)=>{\n            this.sizes[index] = size;\n            if (this.maxSize) {\n                const maxSize = this.maxSize - this.sizes[index];\n                while(this.calculatedSize > maxSize){\n                    this.evict(true);\n                }\n            }\n            this.calculatedSize += this.sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.calculatedSize;\n            }\n        };\n    }\n    removeItemSize(_index) {}\n    addItemSize(_index, _size) {}\n    requireSize(_k, _v, size, sizeCalculation) {\n        if (size || sizeCalculation) {\n            throw new TypeError(\"cannot set size without setting maxSize or maxEntrySize on cache\");\n        }\n    }\n    *indexes({ allowStale = this.allowStale } = {}) {\n        if (this.size) {\n            for(let i = this.tail; true;){\n                if (!this.isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.isStale(i)) {\n                    yield i;\n                }\n                if (i === this.head) {\n                    break;\n                } else {\n                    i = this.prev[i];\n                }\n            }\n        }\n    }\n    *rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.size) {\n            for(let i = this.head; true;){\n                if (!this.isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.isStale(i)) {\n                    yield i;\n                }\n                if (i === this.tail) {\n                    break;\n                } else {\n                    i = this.next[i];\n                }\n            }\n        }\n    }\n    isValidIndex(index) {\n        return index !== undefined && this.keyMap.get(this.keyList[index]) === index;\n    }\n    *entries() {\n        for (const i of this.indexes()){\n            if (this.valList[i] !== undefined && this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n                yield [\n                    this.keyList[i],\n                    this.valList[i]\n                ];\n            }\n        }\n    }\n    *rentries() {\n        for (const i of this.rindexes()){\n            if (this.valList[i] !== undefined && this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n                yield [\n                    this.keyList[i],\n                    this.valList[i]\n                ];\n            }\n        }\n    }\n    *keys() {\n        for (const i of this.indexes()){\n            if (this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n                yield this.keyList[i];\n            }\n        }\n    }\n    *rkeys() {\n        for (const i of this.rindexes()){\n            if (this.keyList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n                yield this.keyList[i];\n            }\n        }\n    }\n    *values() {\n        for (const i of this.indexes()){\n            if (this.valList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n                yield this.valList[i];\n            }\n        }\n    }\n    *rvalues() {\n        for (const i of this.rindexes()){\n            if (this.valList[i] !== undefined && !this.isBackgroundFetch(this.valList[i])) {\n                yield this.valList[i];\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    find(fn, getOptions) {\n        for (const i of this.indexes()){\n            const v = this.valList[i];\n            const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            if (fn(value, this.keyList[i], this)) {\n                return this.get(this.keyList[i], getOptions);\n            }\n        }\n    }\n    forEach(fn, thisp = this) {\n        for (const i of this.indexes()){\n            const v = this.valList[i];\n            const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            fn.call(thisp, value, this.keyList[i], this);\n        }\n    }\n    rforEach(fn, thisp = this) {\n        for (const i of this.rindexes()){\n            const v = this.valList[i];\n            const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            fn.call(thisp, value, this.keyList[i], this);\n        }\n    }\n    get prune() {\n        deprecatedMethod(\"prune\", \"purgeStale\");\n        return this.purgeStale;\n    }\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.rindexes({\n            allowStale: true\n        })){\n            if (this.isStale(i)) {\n                this.delete(this.keyList[i]);\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    dump() {\n        const arr = [];\n        for (const i of this.indexes({\n            allowStale: true\n        })){\n            const key = this.keyList[i];\n            const v = this.valList[i];\n            const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            const entry = {\n                value\n            };\n            if (this.ttls) {\n                entry.ttl = this.ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.sizes) {\n                entry.size = this.sizes[i];\n            }\n            arr.unshift([\n                key,\n                entry\n            ]);\n        }\n        return arr;\n    }\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr){\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset.\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    dispose(_v, _k, _reason) {}\n    set(k, v, { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, status } = {}) {\n        size = this.requireSize(k, v, size, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = \"miss\";\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case a background fetch is there already.\n            // in non-async cases, this is a no-op\n            this.delete(k);\n            return this;\n        }\n        let index = this.size === 0 ? undefined : this.keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = this.newIndex();\n            this.keyList[index] = k;\n            this.valList[index] = v;\n            this.keyMap.set(k, index);\n            this.next[this.tail] = index;\n            this.prev[index] = this.tail;\n            this.tail = index;\n            this.size++;\n            this.addItemSize(index, size, status);\n            if (status) {\n                status.set = \"add\";\n            }\n            noUpdateTTL = false;\n        } else {\n            // update\n            this.moveToTail(index);\n            const oldVal = this.valList[index];\n            if (v !== oldVal) {\n                if (this.isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error(\"replaced\"));\n                } else {\n                    if (!noDisposeOnSet) {\n                        this.dispose(oldVal, k, \"set\");\n                        if (this.disposeAfter) {\n                            this.disposed.push([\n                                oldVal,\n                                k,\n                                \"set\"\n                            ]);\n                        }\n                    }\n                }\n                this.removeItemSize(index);\n                this.valList[index] = v;\n                this.addItemSize(index, size, status);\n                if (status) {\n                    status.set = \"replace\";\n                    const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;\n                    if (oldValue !== undefined) status.oldValue = oldValue;\n                }\n            } else if (status) {\n                status.set = \"update\";\n            }\n        }\n        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {\n            this.initializeTTLTracking();\n        }\n        if (!noUpdateTTL) {\n            this.setItemTTL(index, ttl, start);\n        }\n        this.statusTTL(status, index);\n        if (this.disposeAfter) {\n            while(this.disposed.length){\n                this.disposeAfter(...this.disposed.shift());\n            }\n        }\n        return this;\n    }\n    newIndex() {\n        if (this.size === 0) {\n            return this.tail;\n        }\n        if (this.size === this.max && this.max !== 0) {\n            return this.evict(false);\n        }\n        if (this.free.length !== 0) {\n            return this.free.pop();\n        }\n        // initial fill, just keep writing down the list\n        return this.initialFill++;\n    }\n    pop() {\n        if (this.size) {\n            const val = this.valList[this.head];\n            this.evict(true);\n            return val;\n        }\n    }\n    evict(free) {\n        const head = this.head;\n        const k = this.keyList[head];\n        const v = this.valList[head];\n        if (this.isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error(\"evicted\"));\n        } else {\n            this.dispose(v, k, \"evict\");\n            if (this.disposeAfter) {\n                this.disposed.push([\n                    v,\n                    k,\n                    \"evict\"\n                ]);\n            }\n        }\n        this.removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.keyList[head] = null;\n            this.valList[head] = null;\n            this.free.push(head);\n        }\n        this.head = this.next[head];\n        this.keyMap.delete(k);\n        this.size--;\n        return head;\n    }\n    has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {\n        const index = this.keyMap.get(k);\n        if (index !== undefined) {\n            if (!this.isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.updateItemAge(index);\n                }\n                if (status) status.has = \"hit\";\n                this.statusTTL(status, index);\n                return true;\n            } else if (status) {\n                status.has = \"stale\";\n                this.statusTTL(status, index);\n            }\n        } else if (status) {\n            status.has = \"miss\";\n        }\n        return false;\n    }\n    // like get(), but without any LRU updating or TTL expiration\n    peek(k, { allowStale = this.allowStale } = {}) {\n        const index = this.keyMap.get(k);\n        if (index !== undefined && (allowStale || !this.isStale(index))) {\n            const v = this.valList[index];\n            // either stale and allowed, or forcing a refresh of non-stale value\n            return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n        }\n    }\n    backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.valList[index];\n        if (this.isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        if (options.signal) {\n            options.signal.addEventListener(\"abort\", ()=>ac.abort(options.signal.reason));\n        }\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context\n        };\n        const cb = (v, updateCache = false)=>{\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort) options.status.fetchAbortIgnored = true;\n                } else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            if (this.valList[index] === p) {\n                if (v === undefined) {\n                    if (p.__staleWhileFetching) {\n                        this.valList[index] = p.__staleWhileFetching;\n                    } else {\n                        this.delete(k);\n                    }\n                } else {\n                    if (options.status) options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er)=>{\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er)=>{\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            if (this.valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || p.__staleWhileFetching === undefined;\n                if (del) {\n                    this.delete(k);\n                } else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.valList[index] = p.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && p.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return p.__staleWhileFetching;\n            } else if (p.__returned === p) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej)=>{\n            this.fetchMethod(k, v, fetchOpts).then((v)=>res(v), rej);\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener(\"abort\", ()=>{\n                if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n                    res();\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = (v)=>cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status) options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        p.__abortController = ac;\n        p.__staleWhileFetching = v;\n        p.__returned = null;\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, p, {\n                ...fetchOpts.options,\n                status: undefined\n            });\n            index = this.keyMap.get(k);\n        } else {\n            this.valList[index] = p;\n        }\n        return p;\n    }\n    isBackgroundFetch(p) {\n        return p && typeof p === \"object\" && typeof p.then === \"function\" && Object.prototype.hasOwnProperty.call(p, \"__staleWhileFetching\") && Object.prototype.hasOwnProperty.call(p, \"__returned\") && (p.__returned === p || p.__returned === null);\n    }\n    // this takes the union of get() and set() opts, because it does both\n    async fetch(k, { // get options\n    allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, // set options\n    ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, // fetch exclusive options\n    noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, fetchContext = this.fetchContext, forceRefresh = false, status, signal } = {}) {\n        if (!this.fetchMethod) {\n            if (status) status.fetch = \"get\";\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal\n        };\n        let index = this.keyMap.get(k);\n        if (index === undefined) {\n            if (status) status.fetch = \"miss\";\n            const p = this.backgroundFetch(k, index, options, fetchContext);\n            return p.__returned = p;\n        } else {\n            // in cache, maybe already fetching\n            const v = this.valList[index];\n            if (this.isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = \"inflight\";\n                    if (stale) status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : v.__returned = v;\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status) status.fetch = \"hit\";\n                this.moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.updateItemAge(index);\n                }\n                this.statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.backgroundFetch(k, index, options, fetchContext);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = hasStale && isStale ? \"stale\" : \"refresh\";\n                if (staleVal && isStale) status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : p.__returned = p;\n        }\n    }\n    get(k, { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = {}) {\n        const index = this.keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.valList[index];\n            const fetching = this.isBackgroundFetch(value);\n            this.statusTTL(status, index);\n            if (this.isStale(index)) {\n                if (status) status.get = \"stale\";\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.delete(k);\n                    }\n                    if (status) status.returnedStale = allowStale;\n                    return allowStale ? value : undefined;\n                } else {\n                    if (status) {\n                        status.returnedStale = allowStale && value.__staleWhileFetching !== undefined;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            } else {\n                if (status) status.get = \"hit\";\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.updateItemAge(index);\n                }\n                return value;\n            }\n        } else if (status) {\n            status.get = \"miss\";\n        }\n    }\n    connect(p, n) {\n        this.prev[n] = p;\n        this.next[p] = n;\n    }\n    moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.tail) {\n            if (index === this.head) {\n                this.head = this.next[index];\n            } else {\n                this.connect(this.prev[index], this.next[index]);\n            }\n            this.connect(this.tail, index);\n            this.tail = index;\n        }\n    }\n    get del() {\n        deprecatedMethod(\"del\", \"delete\");\n        return this.delete;\n    }\n    delete(k) {\n        let deleted = false;\n        if (this.size !== 0) {\n            const index = this.keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.size === 1) {\n                    this.clear();\n                } else {\n                    this.removeItemSize(index);\n                    const v = this.valList[index];\n                    if (this.isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error(\"deleted\"));\n                    } else {\n                        this.dispose(v, k, \"delete\");\n                        if (this.disposeAfter) {\n                            this.disposed.push([\n                                v,\n                                k,\n                                \"delete\"\n                            ]);\n                        }\n                    }\n                    this.keyMap.delete(k);\n                    this.keyList[index] = null;\n                    this.valList[index] = null;\n                    if (index === this.tail) {\n                        this.tail = this.prev[index];\n                    } else if (index === this.head) {\n                        this.head = this.next[index];\n                    } else {\n                        this.next[this.prev[index]] = this.next[index];\n                        this.prev[this.next[index]] = this.prev[index];\n                    }\n                    this.size--;\n                    this.free.push(index);\n                }\n            }\n        }\n        if (this.disposed) {\n            while(this.disposed.length){\n                this.disposeAfter(...this.disposed.shift());\n            }\n        }\n        return deleted;\n    }\n    clear() {\n        for (const index of this.rindexes({\n            allowStale: true\n        })){\n            const v = this.valList[index];\n            if (this.isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error(\"deleted\"));\n            } else {\n                const k = this.keyList[index];\n                this.dispose(v, k, \"delete\");\n                if (this.disposeAfter) {\n                    this.disposed.push([\n                        v,\n                        k,\n                        \"delete\"\n                    ]);\n                }\n            }\n        }\n        this.keyMap.clear();\n        this.valList.fill(null);\n        this.keyList.fill(null);\n        if (this.ttls) {\n            this.ttls.fill(0);\n            this.starts.fill(0);\n        }\n        if (this.sizes) {\n            this.sizes.fill(0);\n        }\n        this.head = 0;\n        this.tail = 0;\n        this.initialFill = 1;\n        this.free.length = 0;\n        this.calculatedSize = 0;\n        this.size = 0;\n        if (this.disposed) {\n            while(this.disposed.length){\n                this.disposeAfter(...this.disposed.shift());\n            }\n        }\n    }\n    get reset() {\n        deprecatedMethod(\"reset\", \"clear\");\n        return this.clear;\n    }\n    get length() {\n        deprecatedProperty(\"length\", \"size\");\n        return this.size;\n    }\n    static get AbortController() {\n        return AC;\n    }\n    static get AbortSignal() {\n        return AS;\n    }\n}\nmodule.exports = LRUCache;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbWktc3VwZXItYXBwLy4vbm9kZV9tb2R1bGVzL25hbWVkLXBsYWNlaG9sZGVycy9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2luZGV4LmpzPzFkYTUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcGVyZiA9XG4gIHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiZcbiAgcGVyZm9ybWFuY2UgJiZcbiAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gcGVyZm9ybWFuY2VcbiAgICA6IERhdGVcblxuY29uc3QgaGFzQWJvcnRDb250cm9sbGVyID0gdHlwZW9mIEFib3J0Q29udHJvbGxlciA9PT0gJ2Z1bmN0aW9uJ1xuXG4vLyBtaW5pbWFsIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHBvbHlmaWxsXG4vLyB0aGlzIGRvZXNuJ3QgaGF2ZSBuZWFybHkgYWxsIHRoZSBjaGVja3MgYW5kIHdoYXRub3QgdGhhdFxuLy8gYWN0dWFsIEFib3J0Q29udHJvbGxlci9TaWduYWwgaGFzLCBidXQgaXQncyBlbm91Z2ggZm9yXG4vLyBvdXIgcHVycG9zZXMsIGFuZCBpZiB1c2VkIHByb3Blcmx5LCBiZWhhdmVzIHRoZSBzYW1lLlxuY29uc3QgQUMgPSBoYXNBYm9ydENvbnRyb2xsZXJcbiAgPyBBYm9ydENvbnRyb2xsZXJcbiAgOiBjbGFzcyBBYm9ydENvbnRyb2xsZXIge1xuICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2lnbmFsID0gbmV3IEFTKClcbiAgICAgIH1cbiAgICAgIGFib3J0KHJlYXNvbiA9IG5ldyBFcnJvcignVGhpcyBvcGVyYXRpb24gd2FzIGFib3J0ZWQnKSkge1xuICAgICAgICB0aGlzLnNpZ25hbC5yZWFzb24gPSB0aGlzLnNpZ25hbC5yZWFzb24gfHwgcmVhc29uXG4gICAgICAgIHRoaXMuc2lnbmFsLmFib3J0ZWQgPSB0cnVlXG4gICAgICAgIHRoaXMuc2lnbmFsLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdhYm9ydCcsXG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLnNpZ25hbCxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbmNvbnN0IGhhc0Fib3J0U2lnbmFsID0gdHlwZW9mIEFib3J0U2lnbmFsID09PSAnZnVuY3Rpb24nXG4vLyBTb21lIHBvbHlmaWxscyBwdXQgdGhpcyBvbiB0aGUgQUMgY2xhc3MsIG5vdCBnbG9iYWxcbmNvbnN0IGhhc0FDQWJvcnRTaWduYWwgPSB0eXBlb2YgQUMuQWJvcnRTaWduYWwgPT09ICdmdW5jdGlvbidcbmNvbnN0IEFTID0gaGFzQWJvcnRTaWduYWxcbiAgPyBBYm9ydFNpZ25hbFxuICA6IGhhc0FDQWJvcnRTaWduYWxcbiAgPyBBQy5BYm9ydENvbnRyb2xsZXJcbiAgOiBjbGFzcyBBYm9ydFNpZ25hbCB7XG4gICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZWFzb24gPSB1bmRlZmluZWRcbiAgICAgICAgdGhpcy5hYm9ydGVkID0gZmFsc2VcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW11cbiAgICAgIH1cbiAgICAgIGRpc3BhdGNoRXZlbnQoZSkge1xuICAgICAgICBpZiAoZS50eXBlID09PSAnYWJvcnQnKSB7XG4gICAgICAgICAgdGhpcy5hYm9ydGVkID0gdHJ1ZVxuICAgICAgICAgIHRoaXMub25hYm9ydChlKVxuICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGYgPT4gZihlKSwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25hYm9ydCgpIHt9XG4gICAgICBhZGRFdmVudExpc3RlbmVyKGV2LCBmbikge1xuICAgICAgICBpZiAoZXYgPT09ICdhYm9ydCcpIHtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChmbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihldiwgZm4pIHtcbiAgICAgICAgaWYgKGV2ID09PSAnYWJvcnQnKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLmZpbHRlcihmID0+IGYgIT09IGZuKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG5jb25zdCB3YXJuZWQgPSBuZXcgU2V0KClcbmNvbnN0IGRlcHJlY2F0ZWRPcHRpb24gPSAob3B0LCBpbnN0ZWFkKSA9PiB7XG4gIGNvbnN0IGNvZGUgPSBgTFJVX0NBQ0hFX09QVElPTl8ke29wdH1gXG4gIGlmIChzaG91bGRXYXJuKGNvZGUpKSB7XG4gICAgd2Fybihjb2RlLCBgJHtvcHR9IG9wdGlvbmAsIGBvcHRpb25zLiR7aW5zdGVhZH1gLCBMUlVDYWNoZSlcbiAgfVxufVxuY29uc3QgZGVwcmVjYXRlZE1ldGhvZCA9IChtZXRob2QsIGluc3RlYWQpID0+IHtcbiAgY29uc3QgY29kZSA9IGBMUlVfQ0FDSEVfTUVUSE9EXyR7bWV0aG9kfWBcbiAgaWYgKHNob3VsZFdhcm4oY29kZSkpIHtcbiAgICBjb25zdCB7IHByb3RvdHlwZSB9ID0gTFJVQ2FjaGVcbiAgICBjb25zdCB7IGdldCB9ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90b3R5cGUsIG1ldGhvZClcbiAgICB3YXJuKGNvZGUsIGAke21ldGhvZH0gbWV0aG9kYCwgYGNhY2hlLiR7aW5zdGVhZH0oKWAsIGdldClcbiAgfVxufVxuY29uc3QgZGVwcmVjYXRlZFByb3BlcnR5ID0gKGZpZWxkLCBpbnN0ZWFkKSA9PiB7XG4gIGNvbnN0IGNvZGUgPSBgTFJVX0NBQ0hFX1BST1BFUlRZXyR7ZmllbGR9YFxuICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgIGNvbnN0IHsgcHJvdG90eXBlIH0gPSBMUlVDYWNoZVxuICAgIGNvbnN0IHsgZ2V0IH0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwgZmllbGQpXG4gICAgd2Fybihjb2RlLCBgJHtmaWVsZH0gcHJvcGVydHlgLCBgY2FjaGUuJHtpbnN0ZWFkfWAsIGdldClcbiAgfVxufVxuXG5jb25zdCBlbWl0V2FybmluZyA9ICguLi5hKSA9PiB7XG4gIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICBwcm9jZXNzICYmXG4gIHR5cGVvZiBwcm9jZXNzLmVtaXRXYXJuaW5nID09PSAnZnVuY3Rpb24nXG4gICAgPyBwcm9jZXNzLmVtaXRXYXJuaW5nKC4uLmEpXG4gICAgOiBjb25zb2xlLmVycm9yKC4uLmEpXG59XG5cbmNvbnN0IHNob3VsZFdhcm4gPSBjb2RlID0+ICF3YXJuZWQuaGFzKGNvZGUpXG5cbmNvbnN0IHdhcm4gPSAoY29kZSwgd2hhdCwgaW5zdGVhZCwgZm4pID0+IHtcbiAgd2FybmVkLmFkZChjb2RlKVxuICBjb25zdCBtc2cgPSBgVGhlICR7d2hhdH0gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAke2luc3RlYWR9IGluc3RlYWQuYFxuICBlbWl0V2FybmluZyhtc2csICdEZXByZWNhdGlvbldhcm5pbmcnLCBjb2RlLCBmbilcbn1cblxuY29uc3QgaXNQb3NJbnQgPSBuID0+IG4gJiYgbiA9PT0gTWF0aC5mbG9vcihuKSAmJiBuID4gMCAmJiBpc0Zpbml0ZShuKVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIFRoaXMgaXMgYSBsaXR0bGUgYml0IHJpZGljdWxvdXMsIHRiaC5cbiAqIFRoZSBtYXhpbXVtIGFycmF5IGxlbmd0aCBpcyAyXjMyLTEgb3IgdGhlcmVhYm91dHMgb24gbW9zdCBKUyBpbXBscy5cbiAqIEFuZCB3ZWxsIGJlZm9yZSB0aGF0IHBvaW50LCB5b3UncmUgY2FjaGluZyB0aGUgZW50aXJlIHdvcmxkLCBJIG1lYW4sXG4gKiB0aGF0J3MgfjMyR0Igb2YganVzdCBpbnRlZ2VycyBmb3IgdGhlIG5leHQvcHJldiBsaW5rcywgcGx1cyB3aGF0ZXZlclxuICogZWxzZSB0byBob2xkIHRoYXQgbWFueSBrZXlzIGFuZCB2YWx1ZXMuICBKdXN0IGZpbGxpbmcgdGhlIG1lbW9yeSB3aXRoXG4gKiB6ZXJvZXMgYXQgaW5pdCB0aW1lIGlzIGJydXRhbCB3aGVuIHlvdSBnZXQgdGhhdCBiaWcuXG4gKiBCdXQgd2h5IG5vdCBiZSBjb21wbGV0ZT9cbiAqIE1heWJlIGluIHRoZSBmdXR1cmUsIHRoZXNlIGxpbWl0cyB3aWxsIGhhdmUgZXhwYW5kZWQuICovXG5jb25zdCBnZXRVaW50QXJyYXkgPSBtYXggPT5cbiAgIWlzUG9zSW50KG1heClcbiAgICA/IG51bGxcbiAgICA6IG1heCA8PSBNYXRoLnBvdygyLCA4KVxuICAgID8gVWludDhBcnJheVxuICAgIDogbWF4IDw9IE1hdGgucG93KDIsIDE2KVxuICAgID8gVWludDE2QXJyYXlcbiAgICA6IG1heCA8PSBNYXRoLnBvdygyLCAzMilcbiAgICA/IFVpbnQzMkFycmF5XG4gICAgOiBtYXggPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICA/IFplcm9BcnJheVxuICAgIDogbnVsbFxuXG5jbGFzcyBaZXJvQXJyYXkgZXh0ZW5kcyBBcnJheSB7XG4gIGNvbnN0cnVjdG9yKHNpemUpIHtcbiAgICBzdXBlcihzaXplKVxuICAgIHRoaXMuZmlsbCgwKVxuICB9XG59XG5cbmNsYXNzIFN0YWNrIHtcbiAgY29uc3RydWN0b3IobWF4KSB7XG4gICAgaWYgKG1heCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICAgIGNvbnN0IFVpbnRBcnJheSA9IGdldFVpbnRBcnJheShtYXgpXG4gICAgdGhpcy5oZWFwID0gbmV3IFVpbnRBcnJheShtYXgpXG4gICAgdGhpcy5sZW5ndGggPSAwXG4gIH1cbiAgcHVzaChuKSB7XG4gICAgdGhpcy5oZWFwW3RoaXMubGVuZ3RoKytdID0gblxuICB9XG4gIHBvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFwWy0tdGhpcy5sZW5ndGhdXG4gIH1cbn1cblxuY2xhc3MgTFJVQ2FjaGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICBtYXggPSAwLFxuICAgICAgdHRsLFxuICAgICAgdHRsUmVzb2x1dGlvbiA9IDEsXG4gICAgICB0dGxBdXRvcHVyZ2UsXG4gICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgIHVwZGF0ZUFnZU9uSGFzLFxuICAgICAgYWxsb3dTdGFsZSxcbiAgICAgIGRpc3Bvc2UsXG4gICAgICBkaXNwb3NlQWZ0ZXIsXG4gICAgICBub0Rpc3Bvc2VPblNldCxcbiAgICAgIG5vVXBkYXRlVFRMLFxuICAgICAgbWF4U2l6ZSA9IDAsXG4gICAgICBtYXhFbnRyeVNpemUgPSAwLFxuICAgICAgc2l6ZUNhbGN1bGF0aW9uLFxuICAgICAgZmV0Y2hNZXRob2QsXG4gICAgICBmZXRjaENvbnRleHQsXG4gICAgICBub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24sXG4gICAgICBub0RlbGV0ZU9uU3RhbGVHZXQsXG4gICAgICBhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbixcbiAgICAgIGFsbG93U3RhbGVPbkZldGNoQWJvcnQsXG4gICAgICBpZ25vcmVGZXRjaEFib3J0LFxuICAgIH0gPSBvcHRpb25zXG5cbiAgICAvLyBkZXByZWNhdGVkIG9wdGlvbnMsIGRvbid0IHRyaWdnZXIgYSB3YXJuaW5nIGZvciBnZXR0aW5nIHRoZW0gaWZcbiAgICAvLyB0aGUgdGhpbmcgYmVpbmcgcGFzc2VkIGluIGlzIGFub3RoZXIgTFJVQ2FjaGUgd2UncmUgY29weWluZy5cbiAgICBjb25zdCB7IGxlbmd0aCwgbWF4QWdlLCBzdGFsZSB9ID1cbiAgICAgIG9wdGlvbnMgaW5zdGFuY2VvZiBMUlVDYWNoZSA/IHt9IDogb3B0aW9uc1xuXG4gICAgaWYgKG1heCAhPT0gMCAmJiAhaXNQb3NJbnQobWF4KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG9wdGlvbiBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlcicpXG4gICAgfVxuXG4gICAgY29uc3QgVWludEFycmF5ID0gbWF4ID8gZ2V0VWludEFycmF5KG1heCkgOiBBcnJheVxuICAgIGlmICghVWludEFycmF5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWF4IHZhbHVlOiAnICsgbWF4KVxuICAgIH1cblxuICAgIHRoaXMubWF4ID0gbWF4XG4gICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZVxuICAgIHRoaXMubWF4RW50cnlTaXplID0gbWF4RW50cnlTaXplIHx8IHRoaXMubWF4U2l6ZVxuICAgIHRoaXMuc2l6ZUNhbGN1bGF0aW9uID0gc2l6ZUNhbGN1bGF0aW9uIHx8IGxlbmd0aFxuICAgIGlmICh0aGlzLnNpemVDYWxjdWxhdGlvbikge1xuICAgICAgaWYgKCF0aGlzLm1heFNpemUgJiYgIXRoaXMubWF4RW50cnlTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ2Nhbm5vdCBzZXQgc2l6ZUNhbGN1bGF0aW9uIHdpdGhvdXQgc2V0dGluZyBtYXhTaXplIG9yIG1heEVudHJ5U2l6ZSdcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNpemVDYWxjdWxhdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplQ2FsY3VsYXRpb24gc2V0IHRvIG5vbi1mdW5jdGlvbicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mZXRjaE1ldGhvZCA9IGZldGNoTWV0aG9kIHx8IG51bGxcbiAgICBpZiAodGhpcy5mZXRjaE1ldGhvZCAmJiB0eXBlb2YgdGhpcy5mZXRjaE1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ2ZldGNoTWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbiBpZiBzcGVjaWZpZWQnXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5mZXRjaENvbnRleHQgPSBmZXRjaENvbnRleHRcbiAgICBpZiAoIXRoaXMuZmV0Y2hNZXRob2QgJiYgZmV0Y2hDb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdjYW5ub3Qgc2V0IGZldGNoQ29udGV4dCB3aXRob3V0IGZldGNoTWV0aG9kJ1xuICAgICAgKVxuICAgIH1cblxuICAgIHRoaXMua2V5TWFwID0gbmV3IE1hcCgpXG4gICAgdGhpcy5rZXlMaXN0ID0gbmV3IEFycmF5KG1heCkuZmlsbChudWxsKVxuICAgIHRoaXMudmFsTGlzdCA9IG5ldyBBcnJheShtYXgpLmZpbGwobnVsbClcbiAgICB0aGlzLm5leHQgPSBuZXcgVWludEFycmF5KG1heClcbiAgICB0aGlzLnByZXYgPSBuZXcgVWludEFycmF5KG1heClcbiAgICB0aGlzLmhlYWQgPSAwXG4gICAgdGhpcy50YWlsID0gMFxuICAgIHRoaXMuZnJlZSA9IG5ldyBTdGFjayhtYXgpXG4gICAgdGhpcy5pbml0aWFsRmlsbCA9IDFcbiAgICB0aGlzLnNpemUgPSAwXG5cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuZGlzcG9zZSA9IGRpc3Bvc2VcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkaXNwb3NlQWZ0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuZGlzcG9zZUFmdGVyID0gZGlzcG9zZUFmdGVyXG4gICAgICB0aGlzLmRpc3Bvc2VkID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwb3NlQWZ0ZXIgPSBudWxsXG4gICAgICB0aGlzLmRpc3Bvc2VkID0gbnVsbFxuICAgIH1cbiAgICB0aGlzLm5vRGlzcG9zZU9uU2V0ID0gISFub0Rpc3Bvc2VPblNldFxuICAgIHRoaXMubm9VcGRhdGVUVEwgPSAhIW5vVXBkYXRlVFRMXG4gICAgdGhpcy5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24gPSAhIW5vRGVsZXRlT25GZXRjaFJlamVjdGlvblxuICAgIHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24gPSAhIWFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uXG4gICAgdGhpcy5hbGxvd1N0YWxlT25GZXRjaEFib3J0ID0gISFhbGxvd1N0YWxlT25GZXRjaEFib3J0XG4gICAgdGhpcy5pZ25vcmVGZXRjaEFib3J0ID0gISFpZ25vcmVGZXRjaEFib3J0XG5cbiAgICAvLyBOQjogbWF4RW50cnlTaXplIGlzIHNldCB0byBtYXhTaXplIGlmIGl0J3Mgc2V0XG4gICAgaWYgKHRoaXMubWF4RW50cnlTaXplICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5tYXhTaXplICE9PSAwKSB7XG4gICAgICAgIGlmICghaXNQb3NJbnQodGhpcy5tYXhTaXplKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnbWF4U2l6ZSBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQnXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzUG9zSW50KHRoaXMubWF4RW50cnlTaXplKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdtYXhFbnRyeVNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgICB0aGlzLmluaXRpYWxpemVTaXplVHJhY2tpbmcoKVxuICAgIH1cblxuICAgIHRoaXMuYWxsb3dTdGFsZSA9ICEhYWxsb3dTdGFsZSB8fCAhIXN0YWxlXG4gICAgdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQgPSAhIW5vRGVsZXRlT25TdGFsZUdldFxuICAgIHRoaXMudXBkYXRlQWdlT25HZXQgPSAhIXVwZGF0ZUFnZU9uR2V0XG4gICAgdGhpcy51cGRhdGVBZ2VPbkhhcyA9ICEhdXBkYXRlQWdlT25IYXNcbiAgICB0aGlzLnR0bFJlc29sdXRpb24gPVxuICAgICAgaXNQb3NJbnQodHRsUmVzb2x1dGlvbikgfHwgdHRsUmVzb2x1dGlvbiA9PT0gMFxuICAgICAgICA/IHR0bFJlc29sdXRpb25cbiAgICAgICAgOiAxXG4gICAgdGhpcy50dGxBdXRvcHVyZ2UgPSAhIXR0bEF1dG9wdXJnZVxuICAgIHRoaXMudHRsID0gdHRsIHx8IG1heEFnZSB8fCAwXG4gICAgaWYgKHRoaXMudHRsKSB7XG4gICAgICBpZiAoIWlzUG9zSW50KHRoaXMudHRsKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICd0dGwgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJ1xuICAgICAgICApXG4gICAgICB9XG4gICAgICB0aGlzLmluaXRpYWxpemVUVExUcmFja2luZygpXG4gICAgfVxuXG4gICAgLy8gZG8gbm90IGFsbG93IGNvbXBsZXRlbHkgdW5ib3VuZGVkIGNhY2hlc1xuICAgIGlmICh0aGlzLm1heCA9PT0gMCAmJiB0aGlzLnR0bCA9PT0gMCAmJiB0aGlzLm1heFNpemUgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdBdCBsZWFzdCBvbmUgb2YgbWF4LCBtYXhTaXplLCBvciB0dGwgaXMgcmVxdWlyZWQnXG4gICAgICApXG4gICAgfVxuICAgIGlmICghdGhpcy50dGxBdXRvcHVyZ2UgJiYgIXRoaXMubWF4ICYmICF0aGlzLm1heFNpemUpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSAnTFJVX0NBQ0hFX1VOQk9VTkRFRCdcbiAgICAgIGlmIChzaG91bGRXYXJuKGNvZGUpKSB7XG4gICAgICAgIHdhcm5lZC5hZGQoY29kZSlcbiAgICAgICAgY29uc3QgbXNnID1cbiAgICAgICAgICAnVFRMIGNhY2hpbmcgd2l0aG91dCB0dGxBdXRvcHVyZ2UsIG1heCwgb3IgbWF4U2l6ZSBjYW4gJyArXG4gICAgICAgICAgJ3Jlc3VsdCBpbiB1bmJvdW5kZWQgbWVtb3J5IGNvbnN1bXB0aW9uLidcbiAgICAgICAgZW1pdFdhcm5pbmcobXNnLCAnVW5ib3VuZGVkQ2FjaGVXYXJuaW5nJywgY29kZSwgTFJVQ2FjaGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YWxlKSB7XG4gICAgICBkZXByZWNhdGVkT3B0aW9uKCdzdGFsZScsICdhbGxvd1N0YWxlJylcbiAgICB9XG4gICAgaWYgKG1heEFnZSkge1xuICAgICAgZGVwcmVjYXRlZE9wdGlvbignbWF4QWdlJywgJ3R0bCcpXG4gICAgfVxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGRlcHJlY2F0ZWRPcHRpb24oJ2xlbmd0aCcsICdzaXplQ2FsY3VsYXRpb24nKVxuICAgIH1cbiAgfVxuXG4gIGdldFJlbWFpbmluZ1RUTChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoa2V5LCB7IHVwZGF0ZUFnZU9uSGFzOiBmYWxzZSB9KSA/IEluZmluaXR5IDogMFxuICB9XG5cbiAgaW5pdGlhbGl6ZVRUTFRyYWNraW5nKCkge1xuICAgIHRoaXMudHRscyA9IG5ldyBaZXJvQXJyYXkodGhpcy5tYXgpXG4gICAgdGhpcy5zdGFydHMgPSBuZXcgWmVyb0FycmF5KHRoaXMubWF4KVxuXG4gICAgdGhpcy5zZXRJdGVtVFRMID0gKGluZGV4LCB0dGwsIHN0YXJ0ID0gcGVyZi5ub3coKSkgPT4ge1xuICAgICAgdGhpcy5zdGFydHNbaW5kZXhdID0gdHRsICE9PSAwID8gc3RhcnQgOiAwXG4gICAgICB0aGlzLnR0bHNbaW5kZXhdID0gdHRsXG4gICAgICBpZiAodHRsICE9PSAwICYmIHRoaXMudHRsQXV0b3B1cmdlKSB7XG4gICAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5pc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGUodGhpcy5rZXlMaXN0W2luZGV4XSlcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHR0bCArIDEpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIC0gdW5yZWYoKSBub3Qgc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMgKi9cbiAgICAgICAgaWYgKHQudW5yZWYpIHtcbiAgICAgICAgICB0LnVucmVmKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXBkYXRlSXRlbUFnZSA9IGluZGV4ID0+IHtcbiAgICAgIHRoaXMuc3RhcnRzW2luZGV4XSA9IHRoaXMudHRsc1tpbmRleF0gIT09IDAgPyBwZXJmLm5vdygpIDogMFxuICAgIH1cblxuICAgIHRoaXMuc3RhdHVzVFRMID0gKHN0YXR1cywgaW5kZXgpID0+IHtcbiAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgc3RhdHVzLnR0bCA9IHRoaXMudHRsc1tpbmRleF1cbiAgICAgICAgc3RhdHVzLnN0YXJ0ID0gdGhpcy5zdGFydHNbaW5kZXhdXG4gICAgICAgIHN0YXR1cy5ub3cgPSBjYWNoZWROb3cgfHwgZ2V0Tm93KClcbiAgICAgICAgc3RhdHVzLnJlbWFpbmluZ1RUTCA9IHN0YXR1cy5ub3cgKyBzdGF0dXMudHRsIC0gc3RhdHVzLnN0YXJ0XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGVib3VuY2UgY2FsbHMgdG8gcGVyZi5ub3coKSB0byAxcyBzbyB3ZSdyZSBub3QgaGl0dGluZ1xuICAgIC8vIHRoYXQgY29zdGx5IGNhbGwgcmVwZWF0ZWRseS5cbiAgICBsZXQgY2FjaGVkTm93ID0gMFxuICAgIGNvbnN0IGdldE5vdyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBwZXJmLm5vdygpXG4gICAgICBpZiAodGhpcy50dGxSZXNvbHV0aW9uID4gMCkge1xuICAgICAgICBjYWNoZWROb3cgPSBuXG4gICAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICgpID0+IChjYWNoZWROb3cgPSAwKSxcbiAgICAgICAgICB0aGlzLnR0bFJlc29sdXRpb25cbiAgICAgICAgKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIG5vdCBhdmFpbGFibGUgb24gYWxsIHBsYXRmb3JtcyAqL1xuICAgICAgICBpZiAodC51bnJlZikge1xuICAgICAgICAgIHQudW5yZWYoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gblxuICAgIH1cblxuICAgIHRoaXMuZ2V0UmVtYWluaW5nVFRMID0ga2V5ID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGtleSlcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50dGxzW2luZGV4XSA9PT0gMCB8fCB0aGlzLnN0YXJ0c1tpbmRleF0gPT09IDBcbiAgICAgICAgPyBJbmZpbml0eVxuICAgICAgICA6IHRoaXMuc3RhcnRzW2luZGV4XSArXG4gICAgICAgICAgICB0aGlzLnR0bHNbaW5kZXhdIC1cbiAgICAgICAgICAgIChjYWNoZWROb3cgfHwgZ2V0Tm93KCkpXG4gICAgfVxuXG4gICAgdGhpcy5pc1N0YWxlID0gaW5kZXggPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy50dGxzW2luZGV4XSAhPT0gMCAmJlxuICAgICAgICB0aGlzLnN0YXJ0c1tpbmRleF0gIT09IDAgJiZcbiAgICAgICAgKGNhY2hlZE5vdyB8fCBnZXROb3coKSkgLSB0aGlzLnN0YXJ0c1tpbmRleF0gPlxuICAgICAgICAgIHRoaXMudHRsc1tpbmRleF1cbiAgICAgIClcbiAgICB9XG4gIH1cbiAgdXBkYXRlSXRlbUFnZShfaW5kZXgpIHt9XG4gIHN0YXR1c1RUTChfc3RhdHVzLCBfaW5kZXgpIHt9XG4gIHNldEl0ZW1UVEwoX2luZGV4LCBfdHRsLCBfc3RhcnQpIHt9XG4gIGlzU3RhbGUoX2luZGV4KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpbml0aWFsaXplU2l6ZVRyYWNraW5nKCkge1xuICAgIHRoaXMuY2FsY3VsYXRlZFNpemUgPSAwXG4gICAgdGhpcy5zaXplcyA9IG5ldyBaZXJvQXJyYXkodGhpcy5tYXgpXG4gICAgdGhpcy5yZW1vdmVJdGVtU2l6ZSA9IGluZGV4ID0+IHtcbiAgICAgIHRoaXMuY2FsY3VsYXRlZFNpemUgLT0gdGhpcy5zaXplc1tpbmRleF1cbiAgICAgIHRoaXMuc2l6ZXNbaW5kZXhdID0gMFxuICAgIH1cbiAgICB0aGlzLnJlcXVpcmVTaXplID0gKGssIHYsIHNpemUsIHNpemVDYWxjdWxhdGlvbikgPT4ge1xuICAgICAgLy8gcHJvdmlzaW9uYWxseSBhY2NlcHQgYmFja2dyb3VuZCBmZXRjaGVzLlxuICAgICAgLy8gYWN0dWFsIHZhbHVlIHNpemUgd2lsbCBiZSBjaGVja2VkIHdoZW4gdGhleSByZXR1cm4uXG4gICAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuICAgICAgaWYgKCFpc1Bvc0ludChzaXplKSkge1xuICAgICAgICBpZiAoc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzaXplQ2FsY3VsYXRpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemVDYWxjdWxhdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgICAgICAgIH1cbiAgICAgICAgICBzaXplID0gc2l6ZUNhbGN1bGF0aW9uKHYsIGspXG4gICAgICAgICAgaWYgKCFpc1Bvc0ludChzaXplKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgJ3NpemVDYWxjdWxhdGlvbiByZXR1cm4gaW52YWxpZCAoZXhwZWN0IHBvc2l0aXZlIGludGVnZXIpJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ2ludmFsaWQgc2l6ZSB2YWx1ZSAobXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyKS4gJyArXG4gICAgICAgICAgICAgICdXaGVuIG1heFNpemUgb3IgbWF4RW50cnlTaXplIGlzIHVzZWQsIHNpemVDYWxjdWxhdGlvbiBvciBzaXplICcgK1xuICAgICAgICAgICAgICAnbXVzdCBiZSBzZXQuJ1xuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNpemVcbiAgICB9XG4gICAgdGhpcy5hZGRJdGVtU2l6ZSA9IChpbmRleCwgc2l6ZSwgc3RhdHVzKSA9PiB7XG4gICAgICB0aGlzLnNpemVzW2luZGV4XSA9IHNpemVcbiAgICAgIGlmICh0aGlzLm1heFNpemUpIHtcbiAgICAgICAgY29uc3QgbWF4U2l6ZSA9IHRoaXMubWF4U2l6ZSAtIHRoaXMuc2l6ZXNbaW5kZXhdXG4gICAgICAgIHdoaWxlICh0aGlzLmNhbGN1bGF0ZWRTaXplID4gbWF4U2l6ZSkge1xuICAgICAgICAgIHRoaXMuZXZpY3QodHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5jYWxjdWxhdGVkU2l6ZSArPSB0aGlzLnNpemVzW2luZGV4XVxuICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICBzdGF0dXMuZW50cnlTaXplID0gc2l6ZVxuICAgICAgICBzdGF0dXMudG90YWxDYWxjdWxhdGVkU2l6ZSA9IHRoaXMuY2FsY3VsYXRlZFNpemVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVtb3ZlSXRlbVNpemUoX2luZGV4KSB7fVxuICBhZGRJdGVtU2l6ZShfaW5kZXgsIF9zaXplKSB7fVxuICByZXF1aXJlU2l6ZShfaywgX3YsIHNpemUsIHNpemVDYWxjdWxhdGlvbikge1xuICAgIGlmIChzaXplIHx8IHNpemVDYWxjdWxhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ2Nhbm5vdCBzZXQgc2l6ZSB3aXRob3V0IHNldHRpbmcgbWF4U2l6ZSBvciBtYXhFbnRyeVNpemUgb24gY2FjaGUnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgKmluZGV4ZXMoeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgIGlmICh0aGlzLnNpemUpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnRhaWw7IHRydWU7ICkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZEluZGV4KGkpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsb3dTdGFsZSB8fCAhdGhpcy5pc1N0YWxlKGkpKSB7XG4gICAgICAgICAgeWllbGQgaVxuICAgICAgICB9XG4gICAgICAgIGlmIChpID09PSB0aGlzLmhlYWQpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkgPSB0aGlzLnByZXZbaV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICpyaW5kZXhlcyh7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaGVhZDsgdHJ1ZTsgKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkSW5kZXgoaSkpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd1N0YWxlIHx8ICF0aGlzLmlzU3RhbGUoaSkpIHtcbiAgICAgICAgICB5aWVsZCBpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IHRoaXMudGFpbCkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSA9IHRoaXMubmV4dFtpXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNWYWxpZEluZGV4KGluZGV4KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGluZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIHRoaXMua2V5TWFwLmdldCh0aGlzLmtleUxpc3RbaW5kZXhdKSA9PT0gaW5kZXhcbiAgICApXG4gIH1cblxuICAqZW50cmllcygpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy52YWxMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdGhpcy5rZXlMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIXRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy52YWxMaXN0W2ldKVxuICAgICAgKSB7XG4gICAgICAgIHlpZWxkIFt0aGlzLmtleUxpc3RbaV0sIHRoaXMudmFsTGlzdFtpXV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgKnJlbnRyaWVzKCkge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnJpbmRleGVzKCkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy52YWxMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdGhpcy5rZXlMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIXRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy52YWxMaXN0W2ldKVxuICAgICAgKSB7XG4gICAgICAgIHlpZWxkIFt0aGlzLmtleUxpc3RbaV0sIHRoaXMudmFsTGlzdFtpXV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAqa2V5cygpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5rZXlMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIXRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy52YWxMaXN0W2ldKVxuICAgICAgKSB7XG4gICAgICAgIHlpZWxkIHRoaXMua2V5TGlzdFtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAqcmtleXMoKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoKSkge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmtleUxpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAhdGhpcy5pc0JhY2tncm91bmRGZXRjaCh0aGlzLnZhbExpc3RbaV0pXG4gICAgICApIHtcbiAgICAgICAgeWllbGQgdGhpcy5rZXlMaXN0W2ldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgKnZhbHVlcygpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy52YWxMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIXRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy52YWxMaXN0W2ldKVxuICAgICAgKSB7XG4gICAgICAgIHlpZWxkIHRoaXMudmFsTGlzdFtpXVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAqcnZhbHVlcygpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5yaW5kZXhlcygpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMudmFsTGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICF0aGlzLmlzQmFja2dyb3VuZEZldGNoKHRoaXMudmFsTGlzdFtpXSlcbiAgICAgICkge1xuICAgICAgICB5aWVsZCB0aGlzLnZhbExpc3RbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKClcbiAgfVxuXG4gIGZpbmQoZm4sIGdldE9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKCkpIHtcbiAgICAgIGNvbnN0IHYgPSB0aGlzLnZhbExpc3RbaV1cbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KVxuICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgOiB2XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgY29udGludWVcbiAgICAgIGlmIChmbih2YWx1ZSwgdGhpcy5rZXlMaXN0W2ldLCB0aGlzKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQodGhpcy5rZXlMaXN0W2ldLCBnZXRPcHRpb25zKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvckVhY2goZm4sIHRoaXNwID0gdGhpcykge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLmluZGV4ZXMoKSkge1xuICAgICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtpXVxuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpXG4gICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICA6IHZcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgZm4uY2FsbCh0aGlzcCwgdmFsdWUsIHRoaXMua2V5TGlzdFtpXSwgdGhpcylcbiAgICB9XG4gIH1cblxuICByZm9yRWFjaChmbiwgdGhpc3AgPSB0aGlzKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoKSkge1xuICAgICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtpXVxuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpXG4gICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICA6IHZcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZVxuICAgICAgZm4uY2FsbCh0aGlzcCwgdmFsdWUsIHRoaXMua2V5TGlzdFtpXSwgdGhpcylcbiAgICB9XG4gIH1cblxuICBnZXQgcHJ1bmUoKSB7XG4gICAgZGVwcmVjYXRlZE1ldGhvZCgncHJ1bmUnLCAncHVyZ2VTdGFsZScpXG4gICAgcmV0dXJuIHRoaXMucHVyZ2VTdGFsZVxuICB9XG5cbiAgcHVyZ2VTdGFsZSgpIHtcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlXG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMucmluZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICBpZiAodGhpcy5pc1N0YWxlKGkpKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlKHRoaXMua2V5TGlzdFtpXSlcbiAgICAgICAgZGVsZXRlZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlbGV0ZWRcbiAgfVxuXG4gIGR1bXAoKSB7XG4gICAgY29uc3QgYXJyID0gW11cbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5pbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5rZXlMaXN0W2ldXG4gICAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2ldXG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgIDogdlxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlXG4gICAgICBjb25zdCBlbnRyeSA9IHsgdmFsdWUgfVxuICAgICAgaWYgKHRoaXMudHRscykge1xuICAgICAgICBlbnRyeS50dGwgPSB0aGlzLnR0bHNbaV1cbiAgICAgICAgLy8gYWx3YXlzIGR1bXAgdGhlIHN0YXJ0IHJlbGF0aXZlIHRvIGEgcG9ydGFibGUgdGltZXN0YW1wXG4gICAgICAgIC8vIGl0J3Mgb2sgZm9yIHRoaXMgdG8gYmUgYSBiaXQgc2xvdywgaXQncyBhIHJhcmUgb3BlcmF0aW9uLlxuICAgICAgICBjb25zdCBhZ2UgPSBwZXJmLm5vdygpIC0gdGhpcy5zdGFydHNbaV1cbiAgICAgICAgZW50cnkuc3RhcnQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLSBhZ2UpXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zaXplcykge1xuICAgICAgICBlbnRyeS5zaXplID0gdGhpcy5zaXplc1tpXVxuICAgICAgfVxuICAgICAgYXJyLnVuc2hpZnQoW2tleSwgZW50cnldKVxuICAgIH1cbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICBsb2FkKGFycikge1xuICAgIHRoaXMuY2xlYXIoKVxuICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIGFycikge1xuICAgICAgaWYgKGVudHJ5LnN0YXJ0KSB7XG4gICAgICAgIC8vIGVudHJ5LnN0YXJ0IGlzIGEgcG9ydGFibGUgdGltZXN0YW1wLCBidXQgd2UgbWF5IGJlIHVzaW5nXG4gICAgICAgIC8vIG5vZGUncyBwZXJmb3JtYW5jZS5ub3coKSwgc28gY2FsY3VsYXRlIHRoZSBvZmZzZXQuXG4gICAgICAgIC8vIGl0J3Mgb2sgZm9yIHRoaXMgdG8gYmUgYSBiaXQgc2xvdywgaXQncyBhIHJhcmUgb3BlcmF0aW9uLlxuICAgICAgICBjb25zdCBhZ2UgPSBEYXRlLm5vdygpIC0gZW50cnkuc3RhcnRcbiAgICAgICAgZW50cnkuc3RhcnQgPSBwZXJmLm5vdygpIC0gYWdlXG4gICAgICB9XG4gICAgICB0aGlzLnNldChrZXksIGVudHJ5LnZhbHVlLCBlbnRyeSlcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKF92LCBfaywgX3JlYXNvbikge31cblxuICBzZXQoXG4gICAgayxcbiAgICB2LFxuICAgIHtcbiAgICAgIHR0bCA9IHRoaXMudHRsLFxuICAgICAgc3RhcnQsXG4gICAgICBub0Rpc3Bvc2VPblNldCA9IHRoaXMubm9EaXNwb3NlT25TZXQsXG4gICAgICBzaXplID0gMCxcbiAgICAgIHNpemVDYWxjdWxhdGlvbiA9IHRoaXMuc2l6ZUNhbGN1bGF0aW9uLFxuICAgICAgbm9VcGRhdGVUVEwgPSB0aGlzLm5vVXBkYXRlVFRMLFxuICAgICAgc3RhdHVzLFxuICAgIH0gPSB7fVxuICApIHtcbiAgICBzaXplID0gdGhpcy5yZXF1aXJlU2l6ZShrLCB2LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pXG4gICAgLy8gaWYgdGhlIGl0ZW0gZG9lc24ndCBmaXQsIGRvbid0IGRvIGFueXRoaW5nXG4gICAgLy8gTkI6IG1heEVudHJ5U2l6ZSBzZXQgdG8gbWF4U2l6ZSBieSBkZWZhdWx0XG4gICAgaWYgKHRoaXMubWF4RW50cnlTaXplICYmIHNpemUgPiB0aGlzLm1heEVudHJ5U2l6ZSkge1xuICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICBzdGF0dXMuc2V0ID0gJ21pc3MnXG4gICAgICAgIHN0YXR1cy5tYXhFbnRyeVNpemVFeGNlZWRlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIC8vIGhhdmUgdG8gZGVsZXRlLCBpbiBjYXNlIGEgYmFja2dyb3VuZCBmZXRjaCBpcyB0aGVyZSBhbHJlYWR5LlxuICAgICAgLy8gaW4gbm9uLWFzeW5jIGNhc2VzLCB0aGlzIGlzIGEgbm8tb3BcbiAgICAgIHRoaXMuZGVsZXRlKGspXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBsZXQgaW5kZXggPSB0aGlzLnNpemUgPT09IDAgPyB1bmRlZmluZWQgOiB0aGlzLmtleU1hcC5nZXQoaylcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gYWRkaXRpb25cbiAgICAgIGluZGV4ID0gdGhpcy5uZXdJbmRleCgpXG4gICAgICB0aGlzLmtleUxpc3RbaW5kZXhdID0ga1xuICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IHZcbiAgICAgIHRoaXMua2V5TWFwLnNldChrLCBpbmRleClcbiAgICAgIHRoaXMubmV4dFt0aGlzLnRhaWxdID0gaW5kZXhcbiAgICAgIHRoaXMucHJldltpbmRleF0gPSB0aGlzLnRhaWxcbiAgICAgIHRoaXMudGFpbCA9IGluZGV4XG4gICAgICB0aGlzLnNpemUrK1xuICAgICAgdGhpcy5hZGRJdGVtU2l6ZShpbmRleCwgc2l6ZSwgc3RhdHVzKVxuICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICBzdGF0dXMuc2V0ID0gJ2FkZCdcbiAgICAgIH1cbiAgICAgIG5vVXBkYXRlVFRMID0gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlXG4gICAgICB0aGlzLm1vdmVUb1RhaWwoaW5kZXgpXG4gICAgICBjb25zdCBvbGRWYWwgPSB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgICBpZiAodiAhPT0gb2xkVmFsKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKG9sZFZhbCkpIHtcbiAgICAgICAgICBvbGRWYWwuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdyZXBsYWNlZCcpKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbm9EaXNwb3NlT25TZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZShvbGRWYWwsIGssICdzZXQnKVxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGlzcG9zZWQucHVzaChbb2xkVmFsLCBrLCAnc2V0J10pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbVNpemUoaW5kZXgpXG4gICAgICAgIHRoaXMudmFsTGlzdFtpbmRleF0gPSB2XG4gICAgICAgIHRoaXMuYWRkSXRlbVNpemUoaW5kZXgsIHNpemUsIHN0YXR1cylcbiAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgIHN0YXR1cy5zZXQgPSAncmVwbGFjZSdcbiAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9XG4gICAgICAgICAgICBvbGRWYWwgJiYgdGhpcy5pc0JhY2tncm91bmRGZXRjaChvbGRWYWwpXG4gICAgICAgICAgICAgID8gb2xkVmFsLl9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICAgIDogb2xkVmFsXG4gICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpIHN0YXR1cy5vbGRWYWx1ZSA9IG9sZFZhbHVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICAgIHN0YXR1cy5zZXQgPSAndXBkYXRlJ1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHRsICE9PSAwICYmIHRoaXMudHRsID09PSAwICYmICF0aGlzLnR0bHMpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZVRUTFRyYWNraW5nKClcbiAgICB9XG4gICAgaWYgKCFub1VwZGF0ZVRUTCkge1xuICAgICAgdGhpcy5zZXRJdGVtVFRMKGluZGV4LCB0dGwsIHN0YXJ0KVxuICAgIH1cbiAgICB0aGlzLnN0YXR1c1RUTChzdGF0dXMsIGluZGV4KVxuICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgd2hpbGUgKHRoaXMuZGlzcG9zZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUFmdGVyKC4uLnRoaXMuZGlzcG9zZWQuc2hpZnQoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG5ld0luZGV4KCkge1xuICAgIGlmICh0aGlzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnRhaWxcbiAgICB9XG4gICAgaWYgKHRoaXMuc2l6ZSA9PT0gdGhpcy5tYXggJiYgdGhpcy5tYXggIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmV2aWN0KGZhbHNlKVxuICAgIH1cbiAgICBpZiAodGhpcy5mcmVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZnJlZS5wb3AoKVxuICAgIH1cbiAgICAvLyBpbml0aWFsIGZpbGwsIGp1c3Qga2VlcCB3cml0aW5nIGRvd24gdGhlIGxpc3RcbiAgICByZXR1cm4gdGhpcy5pbml0aWFsRmlsbCsrXG4gIH1cblxuICBwb3AoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy52YWxMaXN0W3RoaXMuaGVhZF1cbiAgICAgIHRoaXMuZXZpY3QodHJ1ZSlcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gIH1cblxuICBldmljdChmcmVlKSB7XG4gICAgY29uc3QgaGVhZCA9IHRoaXMuaGVhZFxuICAgIGNvbnN0IGsgPSB0aGlzLmtleUxpc3RbaGVhZF1cbiAgICBjb25zdCB2ID0gdGhpcy52YWxMaXN0W2hlYWRdXG4gICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdldmljdGVkJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcG9zZSh2LCBrLCAnZXZpY3QnKVxuICAgICAgaWYgKHRoaXMuZGlzcG9zZUFmdGVyKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQucHVzaChbdiwgaywgJ2V2aWN0J10pXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlSXRlbVNpemUoaGVhZClcbiAgICAvLyBpZiB3ZSBhcmVuJ3QgYWJvdXQgdG8gdXNlIHRoZSBpbmRleCwgdGhlbiBudWxsIHRoZXNlIG91dFxuICAgIGlmIChmcmVlKSB7XG4gICAgICB0aGlzLmtleUxpc3RbaGVhZF0gPSBudWxsXG4gICAgICB0aGlzLnZhbExpc3RbaGVhZF0gPSBudWxsXG4gICAgICB0aGlzLmZyZWUucHVzaChoZWFkKVxuICAgIH1cbiAgICB0aGlzLmhlYWQgPSB0aGlzLm5leHRbaGVhZF1cbiAgICB0aGlzLmtleU1hcC5kZWxldGUoaylcbiAgICB0aGlzLnNpemUtLVxuICAgIHJldHVybiBoZWFkXG4gIH1cblxuICBoYXMoaywgeyB1cGRhdGVBZ2VPbkhhcyA9IHRoaXMudXBkYXRlQWdlT25IYXMsIHN0YXR1cyB9ID0ge30pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXRoaXMuaXNTdGFsZShpbmRleCkpIHtcbiAgICAgICAgaWYgKHVwZGF0ZUFnZU9uSGFzKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVJdGVtQWdlKGluZGV4KVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMpIHN0YXR1cy5oYXMgPSAnaGl0J1xuICAgICAgICB0aGlzLnN0YXR1c1RUTChzdGF0dXMsIGluZGV4KVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgc3RhdHVzLmhhcyA9ICdzdGFsZSdcbiAgICAgICAgdGhpcy5zdGF0dXNUVEwoc3RhdHVzLCBpbmRleClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0YXR1cykge1xuICAgICAgc3RhdHVzLmhhcyA9ICdtaXNzJ1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIGxpa2UgZ2V0KCksIGJ1dCB3aXRob3V0IGFueSBMUlUgdXBkYXRpbmcgb3IgVFRMIGV4cGlyYXRpb25cbiAgcGVlayhrLCB7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUgfSA9IHt9KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiAoYWxsb3dTdGFsZSB8fCAhdGhpcy5pc1N0YWxlKGluZGV4KSkpIHtcbiAgICAgIGNvbnN0IHYgPSB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgICAvLyBlaXRoZXIgc3RhbGUgYW5kIGFsbG93ZWQsIG9yIGZvcmNpbmcgYSByZWZyZXNoIG9mIG5vbi1zdGFsZSB2YWx1ZVxuICAgICAgcmV0dXJuIHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nIDogdlxuICAgIH1cbiAgfVxuXG4gIGJhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCkge1xuICAgIGNvbnN0IHYgPSBpbmRleCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdGhpcy52YWxMaXN0W2luZGV4XVxuICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICByZXR1cm4gdlxuICAgIH1cbiAgICBjb25zdCBhYyA9IG5ldyBBQygpXG4gICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICBvcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+XG4gICAgICAgIGFjLmFib3J0KG9wdGlvbnMuc2lnbmFsLnJlYXNvbilcbiAgICAgIClcbiAgICB9XG4gICAgY29uc3QgZmV0Y2hPcHRzID0ge1xuICAgICAgc2lnbmFsOiBhYy5zaWduYWwsXG4gICAgICBvcHRpb25zLFxuICAgICAgY29udGV4dCxcbiAgICB9XG4gICAgY29uc3QgY2IgPSAodiwgdXBkYXRlQ2FjaGUgPSBmYWxzZSkgPT4ge1xuICAgICAgY29uc3QgeyBhYm9ydGVkIH0gPSBhYy5zaWduYWxcbiAgICAgIGNvbnN0IGlnbm9yZUFib3J0ID0gb3B0aW9ucy5pZ25vcmVGZXRjaEFib3J0ICYmIHYgIT09IHVuZGVmaW5lZFxuICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzKSB7XG4gICAgICAgIGlmIChhYm9ydGVkICYmICF1cGRhdGVDYWNoZSkge1xuICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoQWJvcnRlZCA9IHRydWVcbiAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEVycm9yID0gYWMuc2lnbmFsLnJlYXNvblxuICAgICAgICAgIGlmIChpZ25vcmVBYm9ydCkgb3B0aW9ucy5zdGF0dXMuZmV0Y2hBYm9ydElnbm9yZWQgPSB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hSZXNvbHZlZCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFib3J0ZWQgJiYgIWlnbm9yZUFib3J0ICYmICF1cGRhdGVDYWNoZSkge1xuICAgICAgICByZXR1cm4gZmV0Y2hGYWlsKGFjLnNpZ25hbC5yZWFzb24pXG4gICAgICB9XG4gICAgICAvLyBlaXRoZXIgd2UgZGlkbid0IGFib3J0LCBhbmQgYXJlIHN0aWxsIGhlcmUsIG9yIHdlIGRpZCwgYW5kIGlnbm9yZWRcbiAgICAgIGlmICh0aGlzLnZhbExpc3RbaW5kZXhdID09PSBwKSB7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAocC5fX3N0YWxlV2hpbGVGZXRjaGluZykge1xuICAgICAgICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWxldGUoaylcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzKSBvcHRpb25zLnN0YXR1cy5mZXRjaFVwZGF0ZWQgPSB0cnVlXG4gICAgICAgICAgdGhpcy5zZXQoaywgdiwgZmV0Y2hPcHRzLm9wdGlvbnMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2XG4gICAgfVxuICAgIGNvbnN0IGViID0gZXIgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzKSB7XG4gICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoUmVqZWN0ZWQgPSB0cnVlXG4gICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoRXJyb3IgPSBlclxuICAgICAgfVxuICAgICAgcmV0dXJuIGZldGNoRmFpbChlcilcbiAgICB9XG4gICAgY29uc3QgZmV0Y2hGYWlsID0gZXIgPT4ge1xuICAgICAgY29uc3QgeyBhYm9ydGVkIH0gPSBhYy5zaWduYWxcbiAgICAgIGNvbnN0IGFsbG93U3RhbGVBYm9ydGVkID1cbiAgICAgICAgYWJvcnRlZCAmJiBvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoQWJvcnRcbiAgICAgIGNvbnN0IGFsbG93U3RhbGUgPVxuICAgICAgICBhbGxvd1N0YWxlQWJvcnRlZCB8fCBvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uXG4gICAgICBjb25zdCBub0RlbGV0ZSA9IGFsbG93U3RhbGUgfHwgb3B0aW9ucy5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb25cbiAgICAgIGlmICh0aGlzLnZhbExpc3RbaW5kZXhdID09PSBwKSB7XG4gICAgICAgIC8vIGlmIHdlIGFsbG93IHN0YWxlIG9uIGZldGNoIHJlamVjdGlvbnMsIHRoZW4gd2UgbmVlZCB0byBlbnN1cmUgdGhhdFxuICAgICAgICAvLyB0aGUgc3RhbGUgdmFsdWUgaXMgbm90IHJlbW92ZWQgZnJvbSB0aGUgY2FjaGUgd2hlbiB0aGUgZmV0Y2ggZmFpbHMuXG4gICAgICAgIGNvbnN0IGRlbCA9ICFub0RlbGV0ZSB8fCBwLl9fc3RhbGVXaGlsZUZldGNoaW5nID09PSB1bmRlZmluZWRcbiAgICAgICAgaWYgKGRlbCkge1xuICAgICAgICAgIHRoaXMuZGVsZXRlKGspXG4gICAgICAgIH0gZWxzZSBpZiAoIWFsbG93U3RhbGVBYm9ydGVkKSB7XG4gICAgICAgICAgLy8gc3RpbGwgcmVwbGFjZSB0aGUgKnByb21pc2UqIHdpdGggdGhlIHN0YWxlIHZhbHVlLFxuICAgICAgICAgIC8vIHNpbmNlIHdlIGFyZSBkb25lIHdpdGggdGhlIHByb21pc2UgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAvLyBsZWF2ZSBpdCB1bnRvdWNoZWQgaWYgd2UncmUgc3RpbGwgd2FpdGluZyBmb3IgYW5cbiAgICAgICAgICAvLyBhYm9ydGVkIGJhY2tncm91bmQgZmV0Y2ggdGhhdCBoYXNuJ3QgeWV0IHJldHVybmVkLlxuICAgICAgICAgIHRoaXMudmFsTGlzdFtpbmRleF0gPSBwLl9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd1N0YWxlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0YXR1cyAmJiBwLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwLl9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICB9IGVsc2UgaWYgKHAuX19yZXR1cm5lZCA9PT0gcCkge1xuICAgICAgICB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwY2FsbCA9IChyZXMsIHJlaikgPT4ge1xuICAgICAgdGhpcy5mZXRjaE1ldGhvZChrLCB2LCBmZXRjaE9wdHMpLnRoZW4odiA9PiByZXModiksIHJlailcbiAgICAgIC8vIGlnbm9yZWQsIHdlIGdvIHVudGlsIHdlIGZpbmlzaCwgcmVnYXJkbGVzcy5cbiAgICAgIC8vIGRlZmVyIGNoZWNrIHVudGlsIHdlIGFyZSBhY3R1YWxseSBhYm9ydGluZyxcbiAgICAgIC8vIHNvIGZldGNoTWV0aG9kIGNhbiBvdmVycmlkZS5cbiAgICAgIGFjLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFvcHRpb25zLmlnbm9yZUZldGNoQWJvcnQgfHxcbiAgICAgICAgICBvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoQWJvcnRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmVzKClcbiAgICAgICAgICAvLyB3aGVuIGl0IGV2ZW50dWFsbHkgcmVzb2x2ZXMsIHVwZGF0ZSB0aGUgY2FjaGUuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCkge1xuICAgICAgICAgICAgcmVzID0gdiA9PiBjYih2LCB0cnVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3RhdHVzKSBvcHRpb25zLnN0YXR1cy5mZXRjaERpc3BhdGNoZWQgPSB0cnVlXG4gICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKHBjYWxsKS50aGVuKGNiLCBlYilcbiAgICBwLl9fYWJvcnRDb250cm9sbGVyID0gYWNcbiAgICBwLl9fc3RhbGVXaGlsZUZldGNoaW5nID0gdlxuICAgIHAuX19yZXR1cm5lZCA9IG51bGxcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gaW50ZXJuYWwsIGRvbid0IGV4cG9zZSBzdGF0dXMuXG4gICAgICB0aGlzLnNldChrLCBwLCB7IC4uLmZldGNoT3B0cy5vcHRpb25zLCBzdGF0dXM6IHVuZGVmaW5lZCB9KVxuICAgICAgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWxMaXN0W2luZGV4XSA9IHBcbiAgICB9XG4gICAgcmV0dXJuIHBcbiAgfVxuXG4gIGlzQmFja2dyb3VuZEZldGNoKHApIHtcbiAgICByZXR1cm4gKFxuICAgICAgcCAmJlxuICAgICAgdHlwZW9mIHAgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2YgcC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICAgIHAsXG4gICAgICAgICdfX3N0YWxlV2hpbGVGZXRjaGluZydcbiAgICAgICkgJiZcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwLCAnX19yZXR1cm5lZCcpICYmXG4gICAgICAocC5fX3JldHVybmVkID09PSBwIHx8IHAuX19yZXR1cm5lZCA9PT0gbnVsbClcbiAgICApXG4gIH1cblxuICAvLyB0aGlzIHRha2VzIHRoZSB1bmlvbiBvZiBnZXQoKSBhbmQgc2V0KCkgb3B0cywgYmVjYXVzZSBpdCBkb2VzIGJvdGhcbiAgYXN5bmMgZmV0Y2goXG4gICAgayxcbiAgICB7XG4gICAgICAvLyBnZXQgb3B0aW9uc1xuICAgICAgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSxcbiAgICAgIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCxcbiAgICAgIG5vRGVsZXRlT25TdGFsZUdldCA9IHRoaXMubm9EZWxldGVPblN0YWxlR2V0LFxuICAgICAgLy8gc2V0IG9wdGlvbnNcbiAgICAgIHR0bCA9IHRoaXMudHRsLFxuICAgICAgbm9EaXNwb3NlT25TZXQgPSB0aGlzLm5vRGlzcG9zZU9uU2V0LFxuICAgICAgc2l6ZSA9IDAsXG4gICAgICBzaXplQ2FsY3VsYXRpb24gPSB0aGlzLnNpemVDYWxjdWxhdGlvbixcbiAgICAgIG5vVXBkYXRlVFRMID0gdGhpcy5ub1VwZGF0ZVRUTCxcbiAgICAgIC8vIGZldGNoIGV4Y2x1c2l2ZSBvcHRpb25zXG4gICAgICBub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24gPSB0aGlzLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbixcbiAgICAgIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uID0gdGhpcy5hbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbixcbiAgICAgIGlnbm9yZUZldGNoQWJvcnQgPSB0aGlzLmlnbm9yZUZldGNoQWJvcnQsXG4gICAgICBhbGxvd1N0YWxlT25GZXRjaEFib3J0ID0gdGhpcy5hbGxvd1N0YWxlT25GZXRjaEFib3J0LFxuICAgICAgZmV0Y2hDb250ZXh0ID0gdGhpcy5mZXRjaENvbnRleHQsXG4gICAgICBmb3JjZVJlZnJlc2ggPSBmYWxzZSxcbiAgICAgIHN0YXR1cyxcbiAgICAgIHNpZ25hbCxcbiAgICB9ID0ge31cbiAgKSB7XG4gICAgaWYgKCF0aGlzLmZldGNoTWV0aG9kKSB7XG4gICAgICBpZiAoc3RhdHVzKSBzdGF0dXMuZmV0Y2ggPSAnZ2V0J1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KGssIHtcbiAgICAgICAgYWxsb3dTdGFsZSxcbiAgICAgICAgdXBkYXRlQWdlT25HZXQsXG4gICAgICAgIG5vRGVsZXRlT25TdGFsZUdldCxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgYWxsb3dTdGFsZSxcbiAgICAgIHVwZGF0ZUFnZU9uR2V0LFxuICAgICAgbm9EZWxldGVPblN0YWxlR2V0LFxuICAgICAgdHRsLFxuICAgICAgbm9EaXNwb3NlT25TZXQsXG4gICAgICBzaXplLFxuICAgICAgc2l6ZUNhbGN1bGF0aW9uLFxuICAgICAgbm9VcGRhdGVUVEwsXG4gICAgICBub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24sXG4gICAgICBhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbixcbiAgICAgIGFsbG93U3RhbGVPbkZldGNoQWJvcnQsXG4gICAgICBpZ25vcmVGZXRjaEFib3J0LFxuICAgICAgc3RhdHVzLFxuICAgICAgc2lnbmFsLFxuICAgIH1cblxuICAgIGxldCBpbmRleCA9IHRoaXMua2V5TWFwLmdldChrKVxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoc3RhdHVzKSBzdGF0dXMuZmV0Y2ggPSAnbWlzcydcbiAgICAgIGNvbnN0IHAgPSB0aGlzLmJhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgZmV0Y2hDb250ZXh0KVxuICAgICAgcmV0dXJuIChwLl9fcmV0dXJuZWQgPSBwKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbiBjYWNoZSwgbWF5YmUgYWxyZWFkeSBmZXRjaGluZ1xuICAgICAgY29uc3QgdiA9IHRoaXMudmFsTGlzdFtpbmRleF1cbiAgICAgIGlmICh0aGlzLmlzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgIGNvbnN0IHN0YWxlID1cbiAgICAgICAgICBhbGxvd1N0YWxlICYmIHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZFxuICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgc3RhdHVzLmZldGNoID0gJ2luZmxpZ2h0J1xuICAgICAgICAgIGlmIChzdGFsZSkgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWxlID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZyA6ICh2Ll9fcmV0dXJuZWQgPSB2KVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBmb3JjZSBhIHJlZnJlc2gsIHRoYXQgbWVhbnMgZG8gTk9UIHNlcnZlIHRoZSBjYWNoZWQgdmFsdWUsXG4gICAgICAvLyB1bmxlc3Mgd2UgYXJlIGFscmVhZHkgaW4gdGhlIHByb2Nlc3Mgb2YgcmVmcmVzaGluZyB0aGUgY2FjaGUuXG4gICAgICBjb25zdCBpc1N0YWxlID0gdGhpcy5pc1N0YWxlKGluZGV4KVxuICAgICAgaWYgKCFmb3JjZVJlZnJlc2ggJiYgIWlzU3RhbGUpIHtcbiAgICAgICAgaWYgKHN0YXR1cykgc3RhdHVzLmZldGNoID0gJ2hpdCdcbiAgICAgICAgdGhpcy5tb3ZlVG9UYWlsKGluZGV4KVxuICAgICAgICBpZiAodXBkYXRlQWdlT25HZXQpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUl0ZW1BZ2UoaW5kZXgpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0dXNUVEwoc3RhdHVzLCBpbmRleClcbiAgICAgICAgcmV0dXJuIHZcbiAgICAgIH1cblxuICAgICAgLy8gb2ssIGl0IGlzIHN0YWxlIG9yIGEgZm9yY2VkIHJlZnJlc2gsIGFuZCBub3QgYWxyZWFkeSBmZXRjaGluZy5cbiAgICAgIC8vIHJlZnJlc2ggdGhlIGNhY2hlLlxuICAgICAgY29uc3QgcCA9IHRoaXMuYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zLCBmZXRjaENvbnRleHQpXG4gICAgICBjb25zdCBoYXNTdGFsZSA9IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZFxuICAgICAgY29uc3Qgc3RhbGVWYWwgPSBoYXNTdGFsZSAmJiBhbGxvd1N0YWxlXG4gICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgIHN0YXR1cy5mZXRjaCA9IGhhc1N0YWxlICYmIGlzU3RhbGUgPyAnc3RhbGUnIDogJ3JlZnJlc2gnXG4gICAgICAgIGlmIChzdGFsZVZhbCAmJiBpc1N0YWxlKSBzdGF0dXMucmV0dXJuZWRTdGFsZSA9IHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFsZVZhbCA/IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiAocC5fX3JldHVybmVkID0gcClcbiAgICB9XG4gIH1cblxuICBnZXQoXG4gICAgayxcbiAgICB7XG4gICAgICBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlLFxuICAgICAgdXBkYXRlQWdlT25HZXQgPSB0aGlzLnVwZGF0ZUFnZU9uR2V0LFxuICAgICAgbm9EZWxldGVPblN0YWxlR2V0ID0gdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQsXG4gICAgICBzdGF0dXMsXG4gICAgfSA9IHt9XG4gICkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlNYXAuZ2V0KGspXG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWxMaXN0W2luZGV4XVxuICAgICAgY29uc3QgZmV0Y2hpbmcgPSB0aGlzLmlzQmFja2dyb3VuZEZldGNoKHZhbHVlKVxuICAgICAgdGhpcy5zdGF0dXNUVEwoc3RhdHVzLCBpbmRleClcbiAgICAgIGlmICh0aGlzLmlzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgIGlmIChzdGF0dXMpIHN0YXR1cy5nZXQgPSAnc3RhbGUnXG4gICAgICAgIC8vIGRlbGV0ZSBvbmx5IGlmIG5vdCBhbiBpbi1mbGlnaHQgYmFja2dyb3VuZCBmZXRjaFxuICAgICAgICBpZiAoIWZldGNoaW5nKSB7XG4gICAgICAgICAgaWYgKCFub0RlbGV0ZU9uU3RhbGVHZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZXRlKGspXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0dXMpIHN0YXR1cy5yZXR1cm5lZFN0YWxlID0gYWxsb3dTdGFsZVxuICAgICAgICAgIHJldHVybiBhbGxvd1N0YWxlID8gdmFsdWUgOiB1bmRlZmluZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICBzdGF0dXMucmV0dXJuZWRTdGFsZSA9XG4gICAgICAgICAgICAgIGFsbG93U3RhbGUgJiYgdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYWxsb3dTdGFsZSA/IHZhbHVlLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGF0dXMpIHN0YXR1cy5nZXQgPSAnaGl0J1xuICAgICAgICAvLyBpZiB3ZSdyZSBjdXJyZW50bHkgZmV0Y2hpbmcgaXQsIHdlIGRvbid0IGFjdHVhbGx5IGhhdmUgaXQgeWV0XG4gICAgICAgIC8vIGl0J3Mgbm90IHN0YWxlLCB3aGljaCBtZWFucyB0aGlzIGlzbid0IGEgc3RhbGVXaGlsZVJlZmV0Y2hpbmcuXG4gICAgICAgIC8vIElmIGl0J3Mgbm90IHN0YWxlLCBhbmQgZmV0Y2hpbmcsIEFORCBoYXMgYSBfX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAvLyB2YWx1ZSwgdGhlbiB0aGF0IG1lYW5zIHRoZSB1c2VyIGZldGNoZWQgd2l0aCB7Zm9yY2VSZWZyZXNoOnRydWV9LFxuICAgICAgICAvLyBzbyBpdCdzIHNhZmUgdG8gcmV0dXJuIHRoYXQgdmFsdWUuXG4gICAgICAgIGlmIChmZXRjaGluZykge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZVRvVGFpbChpbmRleClcbiAgICAgICAgaWYgKHVwZGF0ZUFnZU9uR2V0KSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVJdGVtQWdlKGluZGV4KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICBzdGF0dXMuZ2V0ID0gJ21pc3MnXG4gICAgfVxuICB9XG5cbiAgY29ubmVjdChwLCBuKSB7XG4gICAgdGhpcy5wcmV2W25dID0gcFxuICAgIHRoaXMubmV4dFtwXSA9IG5cbiAgfVxuXG4gIG1vdmVUb1RhaWwoaW5kZXgpIHtcbiAgICAvLyBpZiB0YWlsIGFscmVhZHksIG5vdGhpbmcgdG8gZG9cbiAgICAvLyBpZiBoZWFkLCBtb3ZlIGhlYWQgdG8gbmV4dFtpbmRleF1cbiAgICAvLyBlbHNlXG4gICAgLy8gICBtb3ZlIG5leHRbcHJldltpbmRleF1dIHRvIG5leHRbaW5kZXhdIChoZWFkIGhhcyBubyBwcmV2KVxuICAgIC8vICAgbW92ZSBwcmV2W25leHRbaW5kZXhdXSB0byBwcmV2W2luZGV4XVxuICAgIC8vIHByZXZbaW5kZXhdID0gdGFpbFxuICAgIC8vIG5leHRbdGFpbF0gPSBpbmRleFxuICAgIC8vIHRhaWwgPSBpbmRleFxuICAgIGlmIChpbmRleCAhPT0gdGhpcy50YWlsKSB7XG4gICAgICBpZiAoaW5kZXggPT09IHRoaXMuaGVhZCkge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLm5leHRbaW5kZXhdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbm5lY3QodGhpcy5wcmV2W2luZGV4XSwgdGhpcy5uZXh0W2luZGV4XSlcbiAgICAgIH1cbiAgICAgIHRoaXMuY29ubmVjdCh0aGlzLnRhaWwsIGluZGV4KVxuICAgICAgdGhpcy50YWlsID0gaW5kZXhcbiAgICB9XG4gIH1cblxuICBnZXQgZGVsKCkge1xuICAgIGRlcHJlY2F0ZWRNZXRob2QoJ2RlbCcsICdkZWxldGUnKVxuICAgIHJldHVybiB0aGlzLmRlbGV0ZVxuICB9XG5cbiAgZGVsZXRlKGspIHtcbiAgICBsZXQgZGVsZXRlZCA9IGZhbHNlXG4gICAgaWYgKHRoaXMuc2l6ZSAhPT0gMCkge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmtleU1hcC5nZXQoaylcbiAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZWQgPSB0cnVlXG4gICAgICAgIGlmICh0aGlzLnNpemUgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLmNsZWFyKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUl0ZW1TaXplKGluZGV4KVxuICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgICAgICAgaWYgKHRoaXMuaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdkZWxldGVkJykpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSh2LCBrLCAnZGVsZXRlJylcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VkLnB1c2goW3YsIGssICdkZWxldGUnXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5rZXlNYXAuZGVsZXRlKGspXG4gICAgICAgICAgdGhpcy5rZXlMaXN0W2luZGV4XSA9IG51bGxcbiAgICAgICAgICB0aGlzLnZhbExpc3RbaW5kZXhdID0gbnVsbFxuICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy50YWlsKSB7XG4gICAgICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnByZXZbaW5kZXhdXG4gICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLm5leHRbaW5kZXhdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFt0aGlzLnByZXZbaW5kZXhdXSA9IHRoaXMubmV4dFtpbmRleF1cbiAgICAgICAgICAgIHRoaXMucHJldlt0aGlzLm5leHRbaW5kZXhdXSA9IHRoaXMucHJldltpbmRleF1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zaXplLS1cbiAgICAgICAgICB0aGlzLmZyZWUucHVzaChpbmRleClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgd2hpbGUgKHRoaXMuZGlzcG9zZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUFmdGVyKC4uLnRoaXMuZGlzcG9zZWQuc2hpZnQoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlbGV0ZWRcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGhpcy5yaW5kZXhlcyh7IGFsbG93U3RhbGU6IHRydWUgfSkpIHtcbiAgICAgIGNvbnN0IHYgPSB0aGlzLnZhbExpc3RbaW5kZXhdXG4gICAgICBpZiAodGhpcy5pc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcignZGVsZXRlZCcpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgayA9IHRoaXMua2V5TGlzdFtpbmRleF1cbiAgICAgICAgdGhpcy5kaXNwb3NlKHYsIGssICdkZWxldGUnKVxuICAgICAgICBpZiAodGhpcy5kaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2VkLnB1c2goW3YsIGssICdkZWxldGUnXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMua2V5TWFwLmNsZWFyKClcbiAgICB0aGlzLnZhbExpc3QuZmlsbChudWxsKVxuICAgIHRoaXMua2V5TGlzdC5maWxsKG51bGwpXG4gICAgaWYgKHRoaXMudHRscykge1xuICAgICAgdGhpcy50dGxzLmZpbGwoMClcbiAgICAgIHRoaXMuc3RhcnRzLmZpbGwoMClcbiAgICB9XG4gICAgaWYgKHRoaXMuc2l6ZXMpIHtcbiAgICAgIHRoaXMuc2l6ZXMuZmlsbCgwKVxuICAgIH1cbiAgICB0aGlzLmhlYWQgPSAwXG4gICAgdGhpcy50YWlsID0gMFxuICAgIHRoaXMuaW5pdGlhbEZpbGwgPSAxXG4gICAgdGhpcy5mcmVlLmxlbmd0aCA9IDBcbiAgICB0aGlzLmNhbGN1bGF0ZWRTaXplID0gMFxuICAgIHRoaXMuc2l6ZSA9IDBcbiAgICBpZiAodGhpcy5kaXNwb3NlZCkge1xuICAgICAgd2hpbGUgKHRoaXMuZGlzcG9zZWQubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZUFmdGVyKC4uLnRoaXMuZGlzcG9zZWQuc2hpZnQoKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgcmVzZXQoKSB7XG4gICAgZGVwcmVjYXRlZE1ldGhvZCgncmVzZXQnLCAnY2xlYXInKVxuICAgIHJldHVybiB0aGlzLmNsZWFyXG4gIH1cblxuICBnZXQgbGVuZ3RoKCkge1xuICAgIGRlcHJlY2F0ZWRQcm9wZXJ0eSgnbGVuZ3RoJywgJ3NpemUnKVxuICAgIHJldHVybiB0aGlzLnNpemVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgQWJvcnRDb250cm9sbGVyKCkge1xuICAgIHJldHVybiBBQ1xuICB9XG4gIHN0YXRpYyBnZXQgQWJvcnRTaWduYWwoKSB7XG4gICAgcmV0dXJuIEFTXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMUlVDYWNoZVxuIl0sIm5hbWVzIjpbInBlcmYiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIkRhdGUiLCJoYXNBYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJBQyIsImNvbnN0cnVjdG9yIiwic2lnbmFsIiwiQVMiLCJhYm9ydCIsInJlYXNvbiIsIkVycm9yIiwiYWJvcnRlZCIsImRpc3BhdGNoRXZlbnQiLCJ0eXBlIiwidGFyZ2V0IiwiaGFzQWJvcnRTaWduYWwiLCJBYm9ydFNpZ25hbCIsImhhc0FDQWJvcnRTaWduYWwiLCJ1bmRlZmluZWQiLCJfbGlzdGVuZXJzIiwiZSIsIm9uYWJvcnQiLCJmb3JFYWNoIiwiZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldiIsImZuIiwicHVzaCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmaWx0ZXIiLCJ3YXJuZWQiLCJTZXQiLCJkZXByZWNhdGVkT3B0aW9uIiwib3B0IiwiaW5zdGVhZCIsImNvZGUiLCJzaG91bGRXYXJuIiwid2FybiIsIkxSVUNhY2hlIiwiZGVwcmVjYXRlZE1ldGhvZCIsIm1ldGhvZCIsInByb3RvdHlwZSIsImdldCIsIk9iamVjdCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImRlcHJlY2F0ZWRQcm9wZXJ0eSIsImZpZWxkIiwiZW1pdFdhcm5pbmciLCJhIiwicHJvY2VzcyIsImNvbnNvbGUiLCJlcnJvciIsImhhcyIsIndoYXQiLCJhZGQiLCJtc2ciLCJpc1Bvc0ludCIsIm4iLCJNYXRoIiwiZmxvb3IiLCJpc0Zpbml0ZSIsImdldFVpbnRBcnJheSIsIm1heCIsInBvdyIsIlVpbnQ4QXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIlplcm9BcnJheSIsIkFycmF5Iiwic2l6ZSIsImZpbGwiLCJTdGFjayIsIlVpbnRBcnJheSIsImhlYXAiLCJsZW5ndGgiLCJwb3AiLCJvcHRpb25zIiwidHRsIiwidHRsUmVzb2x1dGlvbiIsInR0bEF1dG9wdXJnZSIsInVwZGF0ZUFnZU9uR2V0IiwidXBkYXRlQWdlT25IYXMiLCJhbGxvd1N0YWxlIiwiZGlzcG9zZSIsImRpc3Bvc2VBZnRlciIsIm5vRGlzcG9zZU9uU2V0Iiwibm9VcGRhdGVUVEwiLCJtYXhTaXplIiwibWF4RW50cnlTaXplIiwic2l6ZUNhbGN1bGF0aW9uIiwiZmV0Y2hNZXRob2QiLCJmZXRjaENvbnRleHQiLCJub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24iLCJub0RlbGV0ZU9uU3RhbGVHZXQiLCJhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiIsImFsbG93U3RhbGVPbkZldGNoQWJvcnQiLCJpZ25vcmVGZXRjaEFib3J0IiwibWF4QWdlIiwic3RhbGUiLCJUeXBlRXJyb3IiLCJrZXlNYXAiLCJNYXAiLCJrZXlMaXN0IiwidmFsTGlzdCIsIm5leHQiLCJwcmV2IiwiaGVhZCIsInRhaWwiLCJmcmVlIiwiaW5pdGlhbEZpbGwiLCJkaXNwb3NlZCIsImluaXRpYWxpemVTaXplVHJhY2tpbmciLCJpbml0aWFsaXplVFRMVHJhY2tpbmciLCJnZXRSZW1haW5pbmdUVEwiLCJrZXkiLCJJbmZpbml0eSIsInR0bHMiLCJzdGFydHMiLCJzZXRJdGVtVFRMIiwiaW5kZXgiLCJzdGFydCIsInQiLCJzZXRUaW1lb3V0IiwiaXNTdGFsZSIsImRlbGV0ZSIsInVucmVmIiwidXBkYXRlSXRlbUFnZSIsInN0YXR1c1RUTCIsInN0YXR1cyIsImNhY2hlZE5vdyIsImdldE5vdyIsInJlbWFpbmluZ1RUTCIsIl9pbmRleCIsIl9zdGF0dXMiLCJfdHRsIiwiX3N0YXJ0IiwiY2FsY3VsYXRlZFNpemUiLCJzaXplcyIsInJlbW92ZUl0ZW1TaXplIiwicmVxdWlyZVNpemUiLCJrIiwidiIsImlzQmFja2dyb3VuZEZldGNoIiwiYWRkSXRlbVNpemUiLCJldmljdCIsImVudHJ5U2l6ZSIsInRvdGFsQ2FsY3VsYXRlZFNpemUiLCJfc2l6ZSIsIl9rIiwiX3YiLCJpbmRleGVzIiwiaSIsImlzVmFsaWRJbmRleCIsInJpbmRleGVzIiwiZW50cmllcyIsInJlbnRyaWVzIiwia2V5cyIsInJrZXlzIiwidmFsdWVzIiwicnZhbHVlcyIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZmluZCIsImdldE9wdGlvbnMiLCJ2YWx1ZSIsIl9fc3RhbGVXaGlsZUZldGNoaW5nIiwidGhpc3AiLCJjYWxsIiwicmZvckVhY2giLCJwcnVuZSIsInB1cmdlU3RhbGUiLCJkZWxldGVkIiwiZHVtcCIsImFyciIsImVudHJ5IiwiYWdlIiwidW5zaGlmdCIsImxvYWQiLCJjbGVhciIsInNldCIsIl9yZWFzb24iLCJtYXhFbnRyeVNpemVFeGNlZWRlZCIsIm5ld0luZGV4IiwibW92ZVRvVGFpbCIsIm9sZFZhbCIsIl9fYWJvcnRDb250cm9sbGVyIiwib2xkVmFsdWUiLCJzaGlmdCIsInZhbCIsInBlZWsiLCJiYWNrZ3JvdW5kRmV0Y2giLCJjb250ZXh0IiwiYWMiLCJmZXRjaE9wdHMiLCJjYiIsInVwZGF0ZUNhY2hlIiwiaWdub3JlQWJvcnQiLCJmZXRjaEFib3J0ZWQiLCJmZXRjaEVycm9yIiwiZmV0Y2hBYm9ydElnbm9yZWQiLCJmZXRjaFJlc29sdmVkIiwiZmV0Y2hGYWlsIiwicCIsImZldGNoVXBkYXRlZCIsImViIiwiZXIiLCJmZXRjaFJlamVjdGVkIiwiYWxsb3dTdGFsZUFib3J0ZWQiLCJub0RlbGV0ZSIsImRlbCIsInJldHVybmVkU3RhbGUiLCJfX3JldHVybmVkIiwicGNhbGwiLCJyZXMiLCJyZWoiLCJ0aGVuIiwiZmV0Y2hEaXNwYXRjaGVkIiwiUHJvbWlzZSIsImhhc093blByb3BlcnR5IiwiZmV0Y2giLCJmb3JjZVJlZnJlc2giLCJoYXNTdGFsZSIsInN0YWxlVmFsIiwiZmV0Y2hpbmciLCJjb25uZWN0IiwicmVzZXQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQSxNQUFNQSxPQUNKLE9BQU9DLGdCQUFnQixZQUN2QkEsZUFDQSxPQUFPQSxZQUFZQyxHQUFHLEtBQUssYUFDdkJELGNBQ0FFO0FBRU4sTUFBTUMscUJBQXFCLE9BQU9DLG9CQUFvQjtBQUV0RCwyQ0FBMkM7QUFDM0MsMkRBQTJEO0FBQzNELHlEQUF5RDtBQUN6RCx3REFBd0Q7QUFDeEQsTUFBTUMsS0FBS0YscUJBQ1BDLGtCQUNBLE1BQU1BO0lBQ0pFLGFBQWM7UUFDWixJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJQztJQUNwQjtJQUNBQyxNQUFNQyxTQUFTLElBQUlDLE1BQU0sNkJBQTZCLEVBQUU7UUFDdEQsSUFBSSxDQUFDSixNQUFNLENBQUNHLE1BQU0sR0FBRyxJQUFJLENBQUNILE1BQU0sQ0FBQ0csTUFBTSxJQUFJQTtRQUMzQyxJQUFJLENBQUNILE1BQU0sQ0FBQ0ssT0FBTyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0wsTUFBTSxDQUFDTSxhQUFhLENBQUM7WUFDeEJDLE1BQU07WUFDTkMsUUFBUSxJQUFJLENBQUNSLE1BQU07UUFDckI7SUFDRjtBQUNGO0FBRUosTUFBTVMsaUJBQWlCLE9BQU9DLGdCQUFnQjtBQUM5QyxzREFBc0Q7QUFDdEQsTUFBTUMsbUJBQW1CLE9BQU9iLEdBQUdZLFdBQVcsS0FBSztBQUNuRCxNQUFNVCxLQUFLUSxpQkFDUEMsY0FDQUMsbUJBQ0FiLEdBQUdELGVBQWUsR0FDbEIsTUFBTWE7SUFDSlgsYUFBYztRQUNaLElBQUksQ0FBQ0ksTUFBTSxHQUFHUztRQUNkLElBQUksQ0FBQ1AsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDUSxVQUFVLEdBQUcsRUFBRTtJQUN0QjtJQUNBUCxjQUFjUSxDQUFDLEVBQUU7UUFDZixJQUFJQSxFQUFFUCxJQUFJLEtBQUssU0FBUztZQUN0QixJQUFJLENBQUNGLE9BQU8sR0FB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QUFHO1FBQ25CLElBQUksQ0FBQ0QsSUFBSSxDQUFDbEMsTUFBTSxHQUFHO1FBQ25CLElBQUksQ0FBQzhELGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNuRSxJQUFJLEdBQUc7UUFDWixJQUFJLElBQUksQ0FBQ3lDLFFBQVEsRUFBRTtZQUNqQixNQUFPLElBQUksQ0FBQ0EsUUFBUSxDQUFDcEMsTUFBTSxDQUFFO2dCQUMzQixJQUFJLENBQUNVLFlBQVksSUFBSSxJQUFJLENBQUMwQixRQUFRLENBQUM2RSxLQUFLO1lBQzFDO1FBQ0Y7SUFDRjtJQUVBLElBQUlzQyxRQUFRO1FBQ1Y1TCxpQkFBaUIsU0FBUztRQUMxQixPQUFPLElBQUksQ0FBQzZJLEtBQUs7SUFDbkI7SUFFQSxJQUFJeEcsU0FBUztRQUNYL0IsbUJBQW1CLFVBQVU7UUFDN0IsT0FBTyxJQUFJLENBQUMwQixJQUFJO0lBQ2xCO0lBRUEsV0FBV3BFLGtCQUFrQjtRQUMzQixPQUFPQztJQUNUO0lBQ0EsV0FBV1ksY0FBYztRQUN2QixPQUFPVDtJQUNUO0FBQ0Y7QUFFQTZOLE9BQU9DLE9BQU8sR0FBRy9MIiwiZmlsZSI6Iihyc2MpLy4vbm9kZV9tb2R1bGVzL25hbWVkLXBsYWNlaG9sZGVycy9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2luZGV4LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/named-placeholders/node_modules/lru-cache/index.js\n");

/***/ })

};
;