/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/toposort-class";
exports.ids = ["vendor-chunks/toposort-class"];
exports.modules = {

/***/ "(rsc)/./node_modules/toposort-class/build/toposort.js":
/*!*******************************************************!*\
  !*** ./node_modules/toposort-class/build/toposort.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/****\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Gustavo Henke and Aaron Trent\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n ****/ (function(global, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            exports,\n            module\n        ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else { var mod; }\n})(this, function(exports1, module1) {\n    \"use strict\";\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n            throw new TypeError(\"Cannot call a class as a function\");\n        }\n    }\n    var Toposort = function() {\n        function Toposort() {\n            _classCallCheck(this, Toposort);\n            this.edges = [];\n            this.Toposort = Toposort;\n        }\n        /**\n         * Adds dependency edges.\n         *\n         * @since   0.1.0\n         * @param   {String} item               An dependent name. Must be an string and not empty\n         * @param   {String[]|String} [deps]    An dependency or array of dependencies\n         * @returns {Toposort}                  The Toposort instance\n         */ Toposort.prototype.add = function add(item, deps) {\n            if (typeof item !== \"string\" || !item) {\n                throw new TypeError(\"Dependent name must be given as a not empty string\");\n            }\n            deps = Array.isArray(deps) ? deps : [\n                deps\n            ];\n            if (deps.length > 0) {\n                for(var _iterator = deps, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;){\n                    var _ref;\n                    if (_isArray) {\n                        if (_i >= _iterator.length) {\n                            break;\n                        }\n                        _ref = _iterator[_i++];\n                    } else {\n                        _i = _iterator.next();\n                        if (_i.done) {\n                            break;\n                        }\n                        _ref = _i.value;\n                    }\n                    var dep = _ref;\n                    if (typeof dep !== \"string\" || !dep) {\n                        throw new TypeError(\"Dependency name must be given as a not empty string\");\n                    }\n                    this.edges.push([\n                        item,\n                        dep\n                    ]);\n                }\n            } else {\n                this.edges.push([\n                    item\n                ]);\n            }\n            return this;\n        };\n        /**\n         * Runs the toposorting and return an ordered array of strings\n         *\n         * @since   0.1.0\n         * @returns {String[]}  The list of items topologically sorted.\n         */ Toposort.prototype.sort = function sort() {\n            var _this = this;\n            var nodes = [];\n            //accumulate unique nodes into a large list\n            for(var _iterator2 = this.edges, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;){\n                var _ref2;\n                if (_isArray2) {\n                    if (_i2 >= _iterator2.length) {\n                        break;\n                    }\n                    _ref2 = _iterator2[_i2++];\n                } else {\n                    _i2 = _iterator2.next();\n                    if (_i2.done) {\n                        break;\n                    }\n                    _ref2 = _i2.value;\n                }\n                var edge = _ref2;\n                for(var _iterator3 = edge, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;){\n                    var _ref3;\n                    if (_isArray3) {\n                        if (_i3 >= _iterator3.length) {\n                            break;\n                        }\n                        _ref3 = _iterator3[_i3++];\n                    } else {\n                        _i3 = _iterator3.next();\n                        if (_i3.done) {\n                            break;\n                        }\n                        _ref3 = _i3.value;\n                    }\n                    var node = _ref3;\n                    if (nodes.indexOf(node) === -1) {\n                        nodes.push(node);\n                    }\n                }\n            }\n            //initialize the placement of nodes into the sorted array at the end\n            var place = nodes.length;\n            //initialize the sorted array with the same length as the unique nodes array\n            var sorted = new Array(nodes.length);\n            //define a visitor function that recursively traverses dependencies.\n            var visit = function visit(node, predecessors) {\n                //check if a node is dependent of itself\n                if (predecessors.length !== 0 && predecessors.indexOf(node) !== -1) {\n                    throw new Error(\"Cyclic dependency found. \" + node + \" is dependent of itself.\\nDependency chain: \" + predecessors.join(\" -> \") + \" => \" + node);\n                }\n                var index = nodes.indexOf(node);\n                //if the node still exists, traverse its dependencies\n                if (index !== -1) {\n                    var copy = false;\n                    //mark the node as false to exclude it from future iterations\n                    nodes[index] = false;\n                    //loop through all edges and follow dependencies of the current node\n                    for(var _iterator4 = _this.edges, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;){\n                        var _ref4;\n                        if (_isArray4) {\n                            if (_i4 >= _iterator4.length) {\n                                break;\n                            }\n                            _ref4 = _iterator4[_i4++];\n                        } else {\n                            _i4 = _iterator4.next();\n                            if (_i4.done) {\n                                break;\n                            }\n                            _ref4 = _i4.value;\n                        }\n                        var edge = _ref4;\n                        if (edge[0] === node) {\n                            //lazily create a copy of predecessors with the current node concatenated onto it\n                            copy = copy || predecessors.concat([\n                                node\n                            ]);\n                            //recurse to node dependencies\n                            visit(edge[1], copy);\n                        }\n                    }\n                    //add the node to the next place in the sorted array\n                    sorted[--place] = node;\n                }\n            };\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                //ignore nodes that have been excluded\n                if (node !== false) {\n                    //mark the node as false to exclude it from future iterations\n                    nodes[i] = false;\n                    //loop through all edges and follow dependencies of the current node\n                    for(var _iterator5 = this.edges, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;){\n                        var _ref5;\n                        if (_isArray5) {\n                            if (_i5 >= _iterator5.length) {\n                                break;\n                            }\n                            _ref5 = _iterator5[_i5++];\n                        } else {\n                            _i5 = _iterator5.next();\n                            if (_i5.done) {\n                                break;\n                            }\n                            _ref5 = _i5.value;\n                        }\n                        var edge = _ref5;\n                        if (edge[0] === node) {\n                            //recurse to node dependencies\n                            visit(edge[1], [\n                                node\n                            ]);\n                        }\n                    }\n                    //add the node to the next place in the sorted array\n                    sorted[--place] = node;\n                }\n            }\n            return sorted;\n        };\n        /**\n         * Clears edges\n         *\n         * @since   0.4.0\n         * @returns {Toposort}                  The Toposort instance\n         */ Toposort.prototype.clear = function clear() {\n            this.edges = [];\n            return this;\n        };\n        return Toposort;\n    }();\n    module1.exports = Toposort;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdG9wb3NvcnQtY2xhc3MvYnVpbGQvdG9wb3NvcnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBdUJJLEdBQ0gsVUFBVUEsTUFBTSxFQUFFQyxPQUFPO0lBQ3RCLElBQUksSUFBMEMsRUFBRztRQUM3Q0MsaUNBQW9CO1lBQUMsT0FBUztZQUFFLE1BQVE7U0FBQyxvQ0FBRUQsT0FBT0E7QUFBQTtBQUFBO0FBQUEsa0dBQUFBO0lBQ3RELE9BQU8sWUFRTjtBQUNMLEdBQUksSUFBSSxFQUFFLFNBQVVHLFFBQU8sRUFBRUMsT0FBTTtJQUMvQjtJQUVBLFNBQVNHLGdCQUFpQkMsUUFBUSxFQUFFQyxXQUFXO1FBQzNDLElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUs7WUFDckMsTUFBTSxJQUFJQyxVQUFXO1FBQ3pCO0lBQ0o7SUFFQSxJQUFJSixXQUFXO1FBQ1gsU0FBU0E7WUFDTEMsZ0JBQWlCLElBQUksRUFBRUQ7WUFFdkIsSUFBSSxDQUFDSyxLQUFLLEdBQUcsRUFBRTtZQUNmLElBQUksQ0FBQ0wsUUFBUSxHQUFHQTtRQUNwQjtRQUVBOzs7Ozs7O1NBT0MsR0FFREEsU0FBU00sU0FBUyxDQUFDQyxHQUFHLEdBQUcsU0FBU0EsSUFBS0MsSUFBSSxFQUFFQyxJQUFJO1lBQzdDLElBQUksT0FBT0QsU0FBUyxZQUFZLENBQUNBLE1BQU87Z0JBQ3BDLE1BQU0sSUFBSUosVUFBVztZQUN6QjtZQUVBSyxPQUFPQyxNQUFNQyxPQUFPLENBQUVGLFFBQVNBLE9BQU87Z0JBQUNBO2FBQUs7WUFFNUMsSUFBSUEsS0FBS0csTUFBTSxHQUFHLEdBQUk7Z0JBQ2xCLElBQUssSUFBSUMsWUFBWUosTUFBTUssV0FBV0osTUFBTUMsT0FBTyxDQUFFRSxZQUFhRSxLQUFLLEdBQUdGLFlBQVlDLFdBQ0FELFlBQ0FBLFNBQVMsQ0FBQ0csT0FBT0MsUUFBUSxDQUFDLEtBQVE7b0JBQ3BILElBQUlDO29CQUVK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QUFNLEdBQUdGLGFBQWFDLFlBQ0FELGFBQ0FBLFVBQVUsQ0FBQ3BDLE9BQU9DLFFBQVEsQ0FBQyxLQUFRO3dCQUNoSSxJQUFJc0M7d0JBRUosSUFBSUYsV0FBWTs0QkFDWixJQUFJQyxPQUFPRixXQUFXeEMsTUFBTSxFQUFHO2dDQUMzQjs0QkFDSjs0QkFDQTJDLFFBQVFILFVBQVUsQ0FBQ0UsTUFBTTt3QkFDN0IsT0FBTzs0QkFDSEEsTUFBTUYsV0FBV2pDLElBQUk7NEJBQ3JCLElBQUltQyxJQUFJbEMsSUFBSSxFQUFHO2dDQUNYOzRCQUNKOzRCQUNBbUMsUUFBUUQsSUFBSWpDLEtBQUs7d0JBQ3JCO3dCQUVBLElBQUlVLE9BQU93Qjt3QkFFWCxJQUFJeEIsSUFBSSxDQUFDLEVBQUUsS0FBS0ssTUFBTzs0QkFDbkIsOEJBQThCOzRCQUM5QkksTUFBT1QsSUFBSSxDQUFDLEVBQUUsRUFBRTtnQ0FBQ0s7NkJBQUs7d0JBQzFCO29CQUNKO29CQUVBLG9EQUFvRDtvQkFDcERHLE1BQU0sQ0FBQyxFQUFFRCxNQUFNLEdBQUdGO2dCQUN0QjtZQUNKO1lBRUEsT0FBT0c7UUFDWDtRQUVBOzs7OztTQUtDLEdBRUR2QyxTQUFTTSxTQUFTLENBQUNrRCxLQUFLLEdBQUcsU0FBU0E7WUFDaEMsSUFBSSxDQUFDbkQsS0FBSyxHQUFHLEVBQUU7WUFFZixPQUFPLElBQUk7UUFDZjtRQUVBLE9BQU9MO0lBQ1g7SUFFQUYsUUFBT0QsT0FBTyxHQUFHRztBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FtaS1zdXBlci1hcHAvLi9ub2RlX21vZHVsZXMvdG9wb3NvcnQtY2xhc3MvYnVpbGQvdG9wb3NvcnQuanM/NmYyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEd1c3Rhdm8gSGVua2UgYW5kIEFhcm9uIFRyZW50XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqXG4gKioqKi9cbihmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuICAgIGlmKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAgICAgZGVmaW5lKCBcIlRvcG9zb3J0XCIsIFtcImV4cG9ydHNcIiwgXCJtb2R1bGVcIl0sIGZhY3RvcnkgKTtcbiAgICB9IGVsc2UgaWYoIHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICAgIGZhY3RvcnkoIGV4cG9ydHMsIG1vZHVsZSApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtb2QgPSB7XG4gICAgICAgICAgICBleHBvcnRzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBmYWN0b3J5KCBtb2QuZXhwb3J0cywgbW9kICk7XG4gICAgICAgIGdsb2JhbC5Ub3Bvc29ydCA9IG1vZC5leHBvcnRzO1xuICAgIH1cbn0pKCB0aGlzLCBmdW5jdGlvbiggZXhwb3J0cywgbW9kdWxlICkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKCBpbnN0YW5jZSwgQ29uc3RydWN0b3IgKSB7XG4gICAgICAgIGlmKCAhKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpICkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIiApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFRvcG9zb3J0ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBUb3Bvc29ydCgpIHtcbiAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayggdGhpcywgVG9wb3NvcnQgKTtcblxuICAgICAgICAgICAgdGhpcy5lZGdlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5Ub3Bvc29ydCA9IFRvcG9zb3J0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgZGVwZW5kZW5jeSBlZGdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHNpbmNlICAgMC4xLjBcbiAgICAgICAgICogQHBhcmFtICAge1N0cmluZ30gaXRlbSAgICAgICAgICAgICAgIEFuIGRlcGVuZGVudCBuYW1lLiBNdXN0IGJlIGFuIHN0cmluZyBhbmQgbm90IGVtcHR5XG4gICAgICAgICAqIEBwYXJhbSAgIHtTdHJpbmdbXXxTdHJpbmd9IFtkZXBzXSAgICBBbiBkZXBlbmRlbmN5IG9yIGFycmF5IG9mIGRlcGVuZGVuY2llc1xuICAgICAgICAgKiBAcmV0dXJucyB7VG9wb3NvcnR9ICAgICAgICAgICAgICAgICAgVGhlIFRvcG9zb3J0IGluc3RhbmNlXG4gICAgICAgICAqL1xuXG4gICAgICAgIFRvcG9zb3J0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoIGl0ZW0sIGRlcHMgKSB7XG4gICAgICAgICAgICBpZiggdHlwZW9mIGl0ZW0gIT09IFwic3RyaW5nXCIgfHwgIWl0ZW0gKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciggXCJEZXBlbmRlbnQgbmFtZSBtdXN0IGJlIGdpdmVuIGFzIGEgbm90IGVtcHR5IHN0cmluZ1wiICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlcHMgPSBBcnJheS5pc0FycmF5KCBkZXBzICkgPyBkZXBzIDogW2RlcHNdO1xuXG4gICAgICAgICAgICBpZiggZGVwcy5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgICAgIGZvciggdmFyIF9pdGVyYXRvciA9IGRlcHMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSggX2l0ZXJhdG9yICksIF9pID0gMCwgX2l0ZXJhdG9yID0gX2lzQXJyYXkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7IDsgKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmVmO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCBfaXNBcnJheSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaSA+PSBfaXRlcmF0b3IubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pdGVyYXRvcltfaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaS5kb25lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9pLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcCA9IF9yZWY7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIHR5cGVvZiBkZXAgIT09IFwic3RyaW5nXCIgfHwgIWRlcCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIFwiRGVwZW5kZW5jeSBuYW1lIG11c3QgYmUgZ2l2ZW4gYXMgYSBub3QgZW1wdHkgc3RyaW5nXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRnZXMucHVzaCggW2l0ZW0sIGRlcF0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRnZXMucHVzaCggW2l0ZW1dICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSdW5zIHRoZSB0b3Bvc29ydGluZyBhbmQgcmV0dXJuIGFuIG9yZGVyZWQgYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAc2luY2UgICAwLjEuMFxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nW119ICBUaGUgbGlzdCBvZiBpdGVtcyB0b3BvbG9naWNhbGx5IHNvcnRlZC5cbiAgICAgICAgICovXG5cbiAgICAgICAgVG9wb3NvcnQucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiBzb3J0KCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIG5vZGVzID0gW107XG5cbiAgICAgICAgICAgIC8vYWNjdW11bGF0ZSB1bmlxdWUgbm9kZXMgaW50byBhIGxhcmdlIGxpc3RcbiAgICAgICAgICAgIGZvciggdmFyIF9pdGVyYXRvcjIgPSB0aGlzLmVkZ2VzLCBfaXNBcnJheTIgPSBBcnJheS5pc0FycmF5KCBfaXRlcmF0b3IyICksIF9pMiA9IDAsIF9pdGVyYXRvcjIgPSBfaXNBcnJheTIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjJbU3ltYm9sLml0ZXJhdG9yXSgpOyA7ICkge1xuICAgICAgICAgICAgICAgIHZhciBfcmVmMjtcblxuICAgICAgICAgICAgICAgIGlmKCBfaXNBcnJheTIgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKCBfaTIgPj0gX2l0ZXJhdG9yMi5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pdGVyYXRvcjJbX2kyKytdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9pMiA9IF9pdGVyYXRvcjIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiggX2kyLmRvbmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfcmVmMiA9IF9pMi52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRnZSA9IF9yZWYyO1xuXG4gICAgICAgICAgICAgICAgZm9yKCB2YXIgX2l0ZXJhdG9yMyA9IGVkZ2UsIF9pc0FycmF5MyA9IEFycmF5LmlzQXJyYXkoIF9pdGVyYXRvcjMgKSwgX2kzID0gMCwgX2l0ZXJhdG9yMyA9IF9pc0FycmF5MyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjMgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IzW1N5bWJvbC5pdGVyYXRvcl0oKTsgOyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWYzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCBfaXNBcnJheTMgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggX2kzID49IF9pdGVyYXRvcjMubGVuZ3RoICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaXRlcmF0b3IzW19pMysrXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pMyA9IF9pdGVyYXRvcjMubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIF9pMy5kb25lICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3JlZjMgPSBfaTMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IF9yZWYzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCBub2Rlcy5pbmRleE9mKCBub2RlICkgPT09IC0xICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaCggbm9kZSApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2luaXRpYWxpemUgdGhlIHBsYWNlbWVudCBvZiBub2RlcyBpbnRvIHRoZSBzb3J0ZWQgYXJyYXkgYXQgdGhlIGVuZFxuICAgICAgICAgICAgdmFyIHBsYWNlID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAvL2luaXRpYWxpemUgdGhlIHNvcnRlZCBhcnJheSB3aXRoIHRoZSBzYW1lIGxlbmd0aCBhcyB0aGUgdW5pcXVlIG5vZGVzIGFycmF5XG4gICAgICAgICAgICB2YXIgc29ydGVkID0gbmV3IEFycmF5KCBub2Rlcy5sZW5ndGggKTtcblxuICAgICAgICAgICAgLy9kZWZpbmUgYSB2aXNpdG9yIGZ1bmN0aW9uIHRoYXQgcmVjdXJzaXZlbHkgdHJhdmVyc2VzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgIHZhciB2aXNpdCA9IGZ1bmN0aW9uIHZpc2l0KCBub2RlLCBwcmVkZWNlc3NvcnMgKSB7XG4gICAgICAgICAgICAgICAgLy9jaGVjayBpZiBhIG5vZGUgaXMgZGVwZW5kZW50IG9mIGl0c2VsZlxuICAgICAgICAgICAgICAgIGlmKCBwcmVkZWNlc3NvcnMubGVuZ3RoICE9PSAwICYmIHByZWRlY2Vzc29ycy5pbmRleE9mKCBub2RlICkgIT09IC0xICkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIFwiQ3ljbGljIGRlcGVuZGVuY3kgZm91bmQuIFwiICsgbm9kZSArIFwiIGlzIGRlcGVuZGVudCBvZiBpdHNlbGYuXFxuRGVwZW5kZW5jeSBjaGFpbjogXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIHByZWRlY2Vzc29ycy5qb2luKCBcIiAtPiBcIiApICsgXCIgPT4gXCIgKyBub2RlICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbm9kZXMuaW5kZXhPZiggbm9kZSApO1xuXG4gICAgICAgICAgICAgICAgLy9pZiB0aGUgbm9kZSBzdGlsbCBleGlzdHMsIHRyYXZlcnNlIGl0cyBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgICAgICBpZiggaW5kZXggIT09IC0xICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29weSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vbWFyayB0aGUgbm9kZSBhcyBmYWxzZSB0byBleGNsdWRlIGl0IGZyb20gZnV0dXJlIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaW5kZXhdID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9sb29wIHRocm91Z2ggYWxsIGVkZ2VzIGFuZCBmb2xsb3cgZGVwZW5kZW5jaWVzIG9mIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgZm9yKCB2YXIgX2l0ZXJhdG9yNCA9IF90aGlzLmVkZ2VzLCBfaXNBcnJheTQgPSBBcnJheS5pc0FycmF5KCBfaXRlcmF0b3I0ICksIF9pNCA9IDAsIF9pdGVyYXRvcjQgPSBfaXNBcnJheTQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjRbU3ltYm9sLml0ZXJhdG9yXSgpOyA7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggX2lzQXJyYXk0ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaTQgPj0gX2l0ZXJhdG9yNC5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNCA9IF9pdGVyYXRvcjRbX2k0KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTQgPSBfaXRlcmF0b3I0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiggX2k0LmRvbmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNCA9IF9pNC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBfcmVmNDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIGVkZ2VbMF0gPT09IG5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9sYXppbHkgY3JlYXRlIGEgY29weSBvZiBwcmVkZWNlc3NvcnMgd2l0aCB0aGUgY3VycmVudCBub2RlIGNvbmNhdGVuYXRlZCBvbnRvIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IGNvcHkgfHwgcHJlZGVjZXNzb3JzLmNvbmNhdCggW25vZGVdICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JlY3Vyc2UgdG8gbm9kZSBkZXBlbmRlbmNpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdCggZWRnZVsxXSwgY29weSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9hZGQgdGhlIG5vZGUgdG8gdGhlIG5leHQgcGxhY2UgaW4gdGhlIHNvcnRlZCBhcnJheVxuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRbLS1wbGFjZV0gPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgICAgICAgICAgIC8vaWdub3JlIG5vZGVzIHRoYXQgaGF2ZSBiZWVuIGV4Y2x1ZGVkXG4gICAgICAgICAgICAgICAgaWYoIG5vZGUgIT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICAvL21hcmsgdGhlIG5vZGUgYXMgZmFsc2UgdG8gZXhjbHVkZSBpdCBmcm9tIGZ1dHVyZSBpdGVyYXRpb25zXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9sb29wIHRocm91Z2ggYWxsIGVkZ2VzIGFuZCBmb2xsb3cgZGVwZW5kZW5jaWVzIG9mIHRoZSBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgZm9yKCB2YXIgX2l0ZXJhdG9yNSA9IHRoaXMuZWRnZXMsIF9pc0FycmF5NSA9IEFycmF5LmlzQXJyYXkoIF9pdGVyYXRvcjUgKSwgX2k1ID0gMCwgX2l0ZXJhdG9yNSA9IF9pc0FycmF5NSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3I1IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjVbU3ltYm9sLml0ZXJhdG9yXSgpOyA7ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY1O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggX2lzQXJyYXk1ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBfaTUgPj0gX2l0ZXJhdG9yNS5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNSA9IF9pdGVyYXRvcjVbX2k1KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaTUgPSBfaXRlcmF0b3I1Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiggX2k1LmRvbmUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVmNSA9IF9pNS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBfcmVmNTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIGVkZ2VbMF0gPT09IG5vZGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZWN1cnNlIHRvIG5vZGUgZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXQoIGVkZ2VbMV0sIFtub2RlXSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9hZGQgdGhlIG5vZGUgdG8gdGhlIG5leHQgcGxhY2UgaW4gdGhlIHNvcnRlZCBhcnJheVxuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRbLS1wbGFjZV0gPSBub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYXJzIGVkZ2VzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzaW5jZSAgIDAuNC4wXG4gICAgICAgICAqIEByZXR1cm5zIHtUb3Bvc29ydH0gICAgICAgICAgICAgICAgICBUaGUgVG9wb3NvcnQgaW5zdGFuY2VcbiAgICAgICAgICovXG5cbiAgICAgICAgVG9wb3NvcnQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgICB0aGlzLmVkZ2VzID0gW107XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBUb3Bvc29ydDtcbiAgICB9KSgpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBUb3Bvc29ydDtcbn0gKTtcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZGVmaW5lIiwiYW1kIiwiZXhwb3J0cyIsIm1vZHVsZSIsIm1vZCIsIlRvcG9zb3J0IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsImVkZ2VzIiwicHJvdG90eXBlIiwiYWRkIiwiaXRlbSIsImRlcHMiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJfaXRlcmF0b3IiLCJfaXNBcnJheSIsIl9pIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfcmVmIiwibmV4dCIsImRvbmUiLCJ2YWx1ZSIsImRlcCIsInB1c2giLCJzb3J0IiwiX3RoaXMiLCJub2RlcyIsIl9pdGVyYXRvcjIiLCJfaXNBcnJheTIiLCJfaTIiLCJfcmVmMiIsImVkZ2UiLCJfaXRlcmF0b3IzIiwiX2lzQXJyYXkzIiwiX2kzIiwiX3JlZjMiLCJub2RlIiwiaW5kZXhPZiIsInBsYWNlIiwic29ydGVkIiwidmlzaXQiLCJwcmVkZWNlc3NvcnMiLCJFcnJvciIsImpvaW4iLCJpbmRleCIsImNvcHkiLCJfaXRlcmF0b3I0IiwiX2lzQXJyYXk0IiwiX2k0IiwiX3JlZjQiLCJjb25jYXQiLCJpIiwiX2l0ZXJhdG9yNSIsIl9pc0FycmF5NSIsIl9pNSIsIl9yZWY1IiwiY2xlYXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/toposort-class/build/toposort.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/toposort-class/index.js":
/*!**********************************************!*\
  !*** ./node_modules/toposort-class/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./build/toposort.js */ \"(rsc)/./node_modules/toposort-class/build/toposort.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdG9wb3NvcnQtY2xhc3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUFBLHdIQUEwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FtaS1zdXBlci1hcHAvLi9ub2RlX21vZHVsZXMvdG9wb3NvcnQtY2xhc3MvaW5kZXguanM/NWIwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoICcuL2J1aWxkL3RvcG9zb3J0LmpzJyApO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/toposort-class/index.js\n");

/***/ })

};
;